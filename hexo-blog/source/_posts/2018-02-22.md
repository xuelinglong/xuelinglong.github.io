---
title: '2018-02-22'
date: 2018-02-22 19:50:08
tags: 学习总结
---


# JavaScript的事件循环机制

作为一个浏览器脚本语言，JavaScript的主要用途是与用户互动、以及操作DOM。因此它只能是*单线程*，即同一时间只能做一件事情，否则会带来很复杂的同步问题。

为了协调事件、用户交互、脚本、UI渲染和网络处理等行为，防止主线程的阻塞，诞生了Event Loop方案。
<!-- more -->

## Event Loop

主线程从"任务队列"中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。JavaScript就采用这种机制，来解决单线程运行带来的一些问题。

执行栈中的代码（同步任务），总是在读取"任务队列"（异步任务）之前执行。

Event Loop 包含两类：一类是基于 <font color=#F08080>Browsing Context</font> ，一种是基于 <font color=#F08080>Worker</font> 。二者的运行是独立的，也就是说，每一个 JavaScript 运行的"线程环境"都有一个独立的 Event Loop，每一个 Web Worker 也有一个独立的 Event Loop。

### 任务队列

单线程意味着任务需要排队，前面的任务执行完毕后才能执行后面的任务。

一个Event Loop中可以有一个或者多个任务队列，一个任务队列便是<font color=#F08080>一系列有序任务的集合</font>；每个任务都有一个任务源，源自同一个任务源的任务必须放到同一个任务队列，从不同源来的则被添加到不同队列。

setTimeout/Promise 等API便是任务源，而进入任务队列的是他们指定的具体执行任务。注意<font color=#F08080>setTimeout与setInterval是同源的</font>。

任务队列是一个<font color=#F08080>先进先出</font>的数据结构，排在前面的事件，优先被主线程读取。只要执行栈一清空，“任务队列”上的第一位的事件就自动进入主线程。有“定时事件”时主线程要先检查一下执行时间，某些事件只有到了规定的时间才能返回主线程。

### 同步任务

同步任务指的是在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务。

### 异步任务

异步任务指的是不进入主线程、而进入"任务队列"（task queue）的任务，只有"任务队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。

具体来说，异步执行的运行机制如下：

1. 所有同步任务都在主线程上执行，形成一个执行栈。
2. 主线程之外，还存在一个"任务队列"。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。
3. 一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务结束等待状态，进入执行栈开始执行。
4. 主线程不断重复上面的第三步。

异步任务可分为 <font color=#F08080>task</font> 和 <font color=#F08080>microtask（微任务）</font> 两类，不同的API注册的异步任务会依次进入自身对应的队列中，然后等待 Event Loop 将它们依次压入执行栈中执行。task 可理解为macrotask(宏任务)。

(macro)task主要包含：<font color=#F08080>script(整体代码)</font>、<font color=#F08080>setTimeout</font>、<font color=#F08080>setInterval</font>、<font color=#F08080>I/O</font>、<font color=#F08080>UI交互事件</font>、<font color=#F08080>setImmediate(Node.js 环境)</font>。

microtask主要包含：<font color=#F08080>Promise</font>、<font color=#F08080>MutaionObserver</font>、<font color=#F08080>process.nextTick(Node.js 环境)</font>。

### 定时器

“定时器”也就是定时执行的代码，指定某些代码在多少时间后执行。

定时器功能主要由<font color=#F08080>setTimeout()</font>和<font color=#F08080>setInterval()</font>这两个函数来完成，它们两个内部的运行机制完全一样，区别在于<font color=#F08080>前者只执行一次</font>，<font color=#F08080>后者是反复执行</font>。

setTimeout()接受两个参数，第一个是`回调函数`，第二个是`推迟执行的毫秒数`。如果setTimeout()的第二个参数为0，则表示执行栈清空后，立即执行（0毫秒间隔）指定的回调函数。

需要注意的是，setTimeout()<font color=#F08080>只是将事件插入了"任务队列"</font>，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。因此不能保证回调函数一定会在在setTimeout()指定的时间执行。

## 示例

```
console.log('script start');

setTimeout(function() {
  console.log('timeout1');
}, 10);

new Promise(resolve => {
    console.log('promise1');
    resolve();
    setTimeout(() => console.log('timeout2'), 10);
}).then(function() {
    console.log('then1')
})

console.log('script end');

```

解析：

1. 事件循环从宏任务(macrotask)队列开始，此时宏任务队列中只有一个script（整体代码）的任务，当遇到任务源(task source)时，则会先分发任务到对应的任务队列中去。
2. script任务中先**遇到console语句**，因此`先输出 script start`，script任务继续往下执行**遇到setTimeout**，其作为一个宏任务源，则会先将其任务`timeout1`分发到对应的队列中。
3. script 任务继续往下执行，**遇到Promise实例**。Promise 构造函数中的第一个参数是在 new 的时候执行，构造函数执行时，里面的参数进入执行栈执行；而后续的`.then`则会被分发到 microtask 的 Promise 队列中去。所以会先`输出 promise1` ，然后执行 resolve ，将`then1`分配到对应队列。
4. 构造函数继续往下执行，又**遇到setTimeout**，然后将对应的任务`timeout2`分配到对应队列。
5. script任务继续往下执行，`输出script end`，script任务执行完毕。
6. 开始查找清空微任务队列，微任务中只有Promise的`then1`，`输出then1`，microtask清空，第一轮循环结束。
7. 开始第二轮循环，从macrotask开始，此时有`timeout1`和`timeout2`，取出timeout1执行，`输出timeout1`，microtask为空，第二轮循环结束。
8. 开始第三轮循环，从macrotask开始，此时有`timeout2`，取出timeout2执行，`输出timeout2`，microtask为空，第三轮循环结束。
9. 此时宏任务队列与微任务队列都为空，结束。

```
// 输出
script start
promise1
script end
then1
timeout1
timeout2
```

注意：Promise.resolve 方法允许调用时不带参数，直接返回一个 resolved 状态的 Promise 对象。<font color=#F08080>立即 resolved 的 Promise 对象</font>，是<font color=#F08080>在本轮“事件循环”（event loop）的结束时</font>，而不是在下一轮“事件循环”的开始时。

```
new Promise(resolve => {
    resolve(1);
    Promise.resolve().then(() => {
        console.log(2)
    });
    console.log(4)
}).then(t => {
    console.log(t)
});
console.log(3);
```

```
// 输出
4321
```
