---
title: '10月总结[redux为主]'
date: 2018-10-29 20:45:39
tags: 月度总结
---

# 10月总结（redux、vue-slot、js-navigator）

近期终于把困扰许久的redux成功实现了一个，本次总结就梳理一下近期用react、react-redux做练手项目的过程与心得。

## redux

我现在理解redux是与vuex类似的状态管理的库，它有一个完整的特定的更改全局状态的流程。下面来梳理一下我的store注册到全局的过程。

因本次练手项目是使用react全家桶重构手机端CNode中文网，所需要的公共状态有：用户是否登录(用来判断页面显示内容)、用户的登录信息(登录成功后获取，用于登录成功后跳转消息页面可以直接显示用户已读与未读消息)、topic的菜单切换与获取topic数据(用于保存菜单当前选中哪个，跳转到其他tabbar之后再跳转回来时有记录效果、或者进入详情页并回退之后有记录效果)。

<!-- more -->

store就相当于redux中的根部仓库，用于把所有的子reducer整合起来，最后把store注册到全局。现在项目进行到一半，暂时可把store中的子reducer分为3个：user(用户登录、用户info)、topic(获取topic列表、topic详情、收藏、评论、回复)、common(menu切换、tabbar切换)。

一个完整的store由三大部分构成：1.action(dispatch触发action来改变数据状态)；2.reducer(存储全局初始状态、并根据action的类型与参数来改变某些全局数据状态)；3.store(整合所有的子reducer，并把store注册到项目根部index，store中的action与reducer就成功注册到项目全局)。

common(reducer)示例：

* 把项目根组件嵌套到Provider中，那么在组件中都可以使用connect()方法获得redux的store

```Provider、store、app(根部index.js)
import React from 'react';
import ReactDOM from 'react-dom';
import {Provider} from "react-redux";
import store from './redux/store.js';
import './index.css';
import App from './App';
import registerServiceWorker from './registerServiceWorker';

ReactDOM.render((
  <Provider store={store}>
    <App />
  </Provider>
  ),
  document.getElementById('root')
);
registerServiceWorker();
```

* tabbar组件中使用connect()方法获得redux的store

```tabbar.jsx
class PublicTabbar extends Component {
  constructor(props) {
    super(props);
    this.state = {
      selected: 'topics'
    }
  }

  changeSelected(tab, title) {
    // 调用的是common中的action
    this.props.changeTab(tab,title);
  }

  render() {
    return(
      <footer className="PublicTabbar">
        <NavLink className="TabbarItem" to="/">
          <div className={"TabbarItem " + (this.props.selected === 'topics' ? 'selected' : '')} onClick={this.changeSelected.bind(this, 'topics','首页')} >主题</div>
        </NavLink>
        <NavLink className="TabbarItem" to="/message">
          <div className={"TabbarItem " + (this.props.selected === 'message' ? 'selected' : '')} onClick={this.changeSelected.bind(this, 'message','消息')}>消息</div>
        </NavLink>
      </footer>
    );
  }
}

const mapStateToProps = state => ({
  selected: state.common.tab
})

export default connect(mapStateToProps, { changeTab })(PublicTabbar);
```

* common(action)

```action
import * as type from './type'

export const changeTab = (tab, title) => dispatch => {
  dispatch ({
    type: type.CHANGE_TAB,
    tab: tab,
    title: title
  })
}

export const changeMenu = (menu,cb) => dispatch => {
  dispatch ({
    type: type.CHANGE_MENU,
    menu: menu
  })
  cb && cb(menu)
}
```

* common(reducer)

```reducer
import * as type from '../actions/type'
// 初始状态
const initialState = {
  title: '首页',
  tab: 'topics',
  menu: 'all'
}

const common = (state = initialState, action)=> {
  switch(action.type) {
    case type.CHANGE_TAB:
      // {}是保证不直接修改state,新建一个副本并把源对象复制到state中。
      return Object.assign({}, state, {
        tab: action.tab,
        title: action.title
      })
    case type.CHANGE_MENU:
      return Object.assign({}, state, {
        menu: action.menu
      })
    // default的情况下返回旧的state
    default:
      return state;
  }
}

export default common;
```

* (index Reducer)把所有的reducer整合起来

```index-reducer
import { combineReducers } from 'redux'
import common from './common'
import user from './user'
import topics from './topics'

const rootReducers = combineReducers({
  common,
  user,
  topics
});

export default rootReducers;
```

* 创建store

```store
import { createStore, applyMiddleware, compose } from 'redux';
import thunk from 'redux-thunk';
import rootReducer from './reducers/index.js';

const initialState = {};

const middleWear = [thunk];

const store = createStore(
  rootReducer,
  initialState,
  compose(
    applyMiddleware(...middleWear),
    // redux-devtools可以预览必须加上下面的代码
    window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()
  )
);

export default store;
```

## vue(slot、ref)

近期封装vue公共组件，接触到slot与ref，现在梳理一下自己对slot与ref的理解和使用。

slot我理解为占位符，如果父组件为这个插槽提供了内容，那么插槽的默认值会被替换掉。

示例：

```子组件demo.vue
<template>
  <div class="Demo">
    <div class="example-case">
        <slot name="demo"></slot>
    </div>
    <div class="example-desc">
        <slot name="desc"></slot>
    </div>
  </div>
</template>
```

```父组件textCopy.vue
<template calss="textCopy">
  <Demo title="文本复制">
    <div slot="demo">
      // 以下部分会覆盖在demo.vue中的demo具名插槽中
      <span>要被复制的文字：{{copyContent}}</span>
    </div>
    <div slot="desc">
      // 以下部分会覆盖在demo.vue中的desc具名插槽中
      <p>文本复制</p>
    </div>
  </Demo>
</template>
```

ref属性：我们可以在vue组件中的任意html元素上面添加ref属性，然后在组件中可以通过this.$ref.xxx来访问这个DOM元素，示例：

```ref示例
<template>
  <div class="TextCopy">
    <Tooltip v-if="!copied" content="复制文本" placement="top">
      <Icon v-if="!copied" type="ios-copy-outline" @click="copy" :color="this.color" :size="this.size" />
    </Tooltip>
    <Tooltip v-if="copied" content="复制成功" placement="top">
      <Icon v-if="copied" type="checkmark-round" color="#42b983" :size="this.size" />
    </Tooltip>
    <textarea class="textarea" ref="textarea" cols="3" rows="2" readonly=""></textarea>
  </div>
</template>
<script>
export default {
  name: 'TextCopy',
  data() {
    return {
      copied: false
    }
  },
  // ...
  methods: {
    copy() {
      // 通过$ref访问textarea DOM元素
      const faker = this.$refs.textarea
      faker.value = this.copyContent
      faker.focus()
      // 选中这个被focused的input元素的特定范围
      faker.setSelectionRange(0, this.copyContent.length)

      try {
        document.execCommand('copy')
        this.copied = true
        setTimeout(() => { 
          this.copied = false
          this.copiedFun ? this.copiedFun() : null
        }, 500)
      } catch (err) {
        alert('Oops, 看起来您的浏览器不支持自动拷贝, 请选中以上文字复制吧')
      } finally {
        // document.body.removeChild(faker)
      }
    }
  }
}
</script>
```

## navigator

本次做项目调用客户端的方法时，遇到要区分安卓和iOS的情况，经过查找才认识了navigator.userAgent（返回当前浏览器的用户代理字符串），```isAndroid = u.indexOf('Android') > -1 || u.indexOf('Adr') > -1;```可用来区分是否是android。

## 疑难点

1. 异步action的实现方式（本次项目中使用的是成功时执行回调函数，目前已知thunk库可以实现异步action，但是还未真正实现过，待摸索）。

2. router更好的使用方式（本次是把router作为一个Main组件引入到App组件中）。
