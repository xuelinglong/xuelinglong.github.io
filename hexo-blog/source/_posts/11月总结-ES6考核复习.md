---
title: '11月总结[ES6考核复习]'
date: 2018-11-30 23:12:39
tags: 月度总结
---

# 学习范围

近期公司前端组开展基础知识考核，我发现这些都是我目前所欠缺的部分，故本月学习主要围绕在每次知识考核的内容。

考核内容：ES6的ESmodule、Reflect、Class、Proxy、Generator、Promise、Iterator。

## Proxy(代理器)

proxy可以理解为在目标对象之前增加一层拦截，访问目标对象必须经过这层拦截，在拦截中可以对外界的访问进行过滤和改写。

ES6提供Proxy构造函数，用来生成Proxy实例，Proxy构造函数有两个参数target(要拦截的目标对象)、handler(定制拦截行为的一个对象)。

Proxy 支持的拦截操作：

* get(target目标对象, propKey属性名, receiver(proxy实例本身)：拦截对象属性的读取；
* set(target目标对象, propKey属性名, value属性值, receiver(proxy实例本身))：拦截对象属性的设置；
* has(target目标对象, propKey需要查询的属性名)：拦截propKey in proxy的操作，返回一个布尔值，即判断对象是否具有某个属性时生效；
* apply(target目标对象, object目标对象的上下文对象, args目标对象的参数数组)：拦截 Proxy 实例作为函数调用的操作；
* construct(target目标对象, args构造函数的参数对象, NewTarget创造实例对象时new命令作用的构造函数)：拦截 Proxy 实例作为构造函数调用的操作；

<!-- more -->

### get方法注意点：

```示例get方法
let obj = {
  name: '哈哈',
  id: 1
}
let proxyObj = new Proxy(obj, {
  get: function (target, key, value, receiver) {
    if(key=='settleId' || key in target) {
      return key=='settleId' ? target.id : target.key;
    }else {
      throw new ReferenceError("Property \"" + key + "\" does not exist.");
    }
  },
  set (target, property, value) {
    if(property=='settleId') {
      return Reflect.set(target, 'settleId', target.id, receiver);
    }
  }
});

  console.log(proxyObj.settleId);   // 1
  console.log(proxyObj.age);  // 报错Uncaught ReferenceError: Property "age" does not exist.
```

* 如果handler是一个空对象，则没有任何拦截效果，访问proxy等同于访问target。
* 若访问目标对象不存在的属性，只会返回undefined，但是设置拦截函数之后会抛出一个错误。
* 如果一个属性不可配置（configurable）且不可写（writable），则 Proxy 不能修改该属性，否则通过 Proxy 对象访问该属性会报错。

### set方法注意点：

```示例set方法
let obj = {
  name: '哈哈',
  id: 1
}
let proxyObj = new Proxy(obj, {
  get: function (target, property, value) {
    invariant(property, 'get');
    // 对于满足条件的 age 属性以及其他属性，直接保存
    return target[property];
  },
  set: function (target, property, value) {
    if(property=='age') {
      if(!Number.isInteger(value)) {
        throw new TypeError('The age is not an integer');
      }
      if (value > 200) {
        throw new RangeError('The age seems invalid');
      }
    }
    invariant(property, 'set');
    // 对于满足条件的 age 属性以及其他属性，直接保存
    target[property] = value;
  }
});

function invariant (key, action) {
  if (key[0] === '_') {
    throw new Error(`Invalid attempt to ${action} private "${key}" property`);
  }
}
  
proxyObj.age = 100;  // 存储
console.log(obj);
proxyObj._pro = 300;  // 报错Uncaught Error: Invalid attempt to set private "_pro" property.
```

* 结合get和set方法，就可以做到防止内部属性(属性名第一个字符使用下划线)被外部读写；
* 如果目标对象自身的某个属性，不可写且不可配置，那么set方法将不起作用；

### apply方法注意点：

```示例apply方法
let proxyObj = new Proxy(sum, {
  apply: function (target, ctx, args) {
    return Reflect.apply(...arguments)
  }
});
function sum (left, right) {
  return left + right;
};
  
proxyObj(1, 2); // 6
proxyObj.call(null, 5, 6); // 22
proxyObj.apply(null, [7, 8]); // 30
```

* 每当执行proxy函数（直接调用或call和apply调用），就会被apply方法拦截；
* 直接调用Reflect.apply方法，也会被拦截；

### has方法注意点：

* 如果原对象不可配置或者禁止扩展，这时has拦截会报错；
* has方法拦截的是HasProperty操作，而不是HasOwnProperty操作，即has方法不判断一个属性是对象自身的属性，还是继承的属性；

### construct方法注意点：

```示例construct方法
let proxyObj = new Proxy(function (){}, {
  construct: function (target, args) {
    return {value: args[0]*10};
  }
});
  
(new proxyObj(2)).value;  // 20
```

* construct方法返回的必须是一个对象，否则会报错；

## Reflect

Reflect也是ES6为了操作对象而提供的新API，类似Proxy。Reflect与Proxy方法一一对应，也是13个。

Reflect的设计目的：

1. 把Object的语言内部的方法放在Reflect上，即从Reflect对象上可以拿到语言内部的方法。
2. 使修改Object方法的返回结果更合理，在无法定义属性时不会报错而是返回false。
3. 让Object的操作都变成函数行为，如删除对象属性：老写法delect obj('name') ---> 新写法Reflect.deleteProperty(obj, name)；如判断对象中是否含有xxx属性：老写法name in obj ---> 新写法Reflect.has(obj, name)。
4. Reflect对象的方法与Proxy对象的方法一一对应，我理解为使用Proxy修改默认行为，使用Reflect获取默认行为。

![image.png](https://upload-images.jianshu.io/upload_images/1393082-719660a32f36b3ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

* Reflect.get(target, name, receiver)：查找并返回target的name属性，如果没有该属性则返回undefined；如果name属性部署了读取函数，则读取函数的this绑定receiver；

![reflect-get.png](https://upload-images.jianshu.io/upload_images/1393082-24eaa53d942ec50c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

* Reflect.set(target, name, value, receiver)：设置target对象的name属性等于value；如果name属性设置了赋值函数，则赋值函数的this绑定receiver；

![reflect-set.png](https://upload-images.jianshu.io/upload_images/1393082-3ce3e31979101330.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## Class

### constructor

constructor是一个用于创建和初始化使用class创建的对象的方法，一个类只能拥有一个constructor方法，即使没有明显定义constructor，也会默认被添加一个空的constructor，一个构造函数可以使用super关键字来调用一个父类的构造函数。

### prototype属性

可以理解为prototype就是把所有对象连接起来的桥梁，把所有实例对象需要共享的属性和方法放在里面，形成一个prototype对象，实例一旦被创建就会自动引用prototype对象的属性和方法。一旦更改prototype对象里面属性的值，所有实 例里面该属性值都会同时变化。

实例的属性和方法可分为2种：1.引用的prototype中的属性与方法。2.构造函数中的本地属性与方法。

同理讲一个类有固定的属性，但是类的实例却有不同的属性值。

### super

super用来调用父类的构造函数，必须在this之前使用。super作为函数调用时，代表的是父类的构造函数，但是super内部的this指向子类。且super()只能用在子类的构造函数中。

在普通方法中，super作为对象使用，那么它指向父类的原型对象，在静态方法中指向父类。

## Generator函数

Generator函数返回一个遍历器对象，返回的遍历器对象可以依次遍历generator函数内部的每一个状态。

Generator函数的特点是function* name(){...}，函数内部有yield表达式，且直接调用generator函数它并不会立即执行，因为它返回一个指向内部状态的指针对象，必须调用next方法才能使指针移向下一个状态，next方法若是含有参数，则会替代本个yield表达式的值，通常返回的是普通对象{value:xxx,done:false}，当done为true时遍历结束。

一个Generator函数内部可以调用另外的generator函数，只需要使用yield* name()即可。

## 考核题目回顾及解析

```题目
以下代码的执行后，变量result的值是多少?
const target = new Date(2018, 5, 5);
const handler = {};
const proxy = new Proxy(target, handler);

var result = proxy.getDate();

答案: 执行失败，报错: TypeError: this is not a Date object.
主要原因就是在 Proxy 代理的情况下，目标对象内部的this关键字会指向 Proxy 代理
```

```题目
有代码如下:
const proxy = new Proxy({}, {
  get: function(target, property, receiver) {
    return receiver;
  }
});
const obj = Object.create(proxy);

那么，说法表达式的结果为true的有哪些？
A. obj.name == obj
B. obj.name === obj
C. proxy.getReceiver === proxy
D. proxy.getReceiver == proxy

答案: A,B,C,D
解析: proxy对象的getReceiver属性是由proxy对象提供的，receiver指向proxy对象。另外，get方法可以被继承，Object.create创建了obj，而obj的原型是proxy，调用name的时候，实际得到的是自身。
```

```题目
有代码如下:
var twice = {
  apply (target, ctx, args) {
    return Reflect.apply(...arguments) * 2;
  }
};
function sum (left, right) {
  return left + right;
};
var proxy = new Proxy(sum, twice);

var a = proxy(1, 5)
var b = proxy.call(null, 2, 5)
var c = proxy.apply(null, [3, 5])

那么，a，b，c的值分别是多少？
答案: 12 ，14，16
解析: proxy是一个Proxy实例，当实例通过函数调用或者通过call、apply方法调用时就会触发Proxy对apply方法的拦截。
```

```题目
以下代码的输出结果是什么？
Promise.resolve(5)
  .then()
  .then(res => {
    console.log(res)
    return 3
    })
  .then(() => {})
  .then(res => { console.log(res) })

答案：5，undefined
解析：promise有一个自动传递机制，then后面为空，所以会把resolve的值传递下去，因此第一个输出5，后续返回3，但是之后的then返回undefined，因此最后的res就是undefined。
```

```题目
以下代码打印出什么：
let o = {
  a:0
}

o = new Proxy(o,{
  set(target, key, value, proxy) { 
    if (typeof value !== 'number')return 
    return Reflect.set(target, key, value, proxy); }
})

o.a = '1'
console.log(o.a)
答案：0
解析：因为o.a='1'会触发set拦截，且'1'是非Number，因此会直接执行return，且不修改原对象，后续再访问o.a依然是0。
```

```题目
const promise1=new Promise((resolve,reject)=>{
  setTimeout(()=>{
    resolve('success')
  },1000)
})
const promise2 = promise1.then(()=>{
  throw new Error('error!!!');
})
console.log('promise1',promise1)
console.log('promise2',promise2)
setTimeout(()=>{
  console.log('promise1',promise1)
  console.log('promise2',promise2)
},2000)
以上代码执行结果是什么？
执行结果：
  1. promise1, Promise {<pending>}
  2. promise2, Promise {<pending>}
  3. Uncaught (in promise) Error: error!!! (抛异常)
  4. promise1, Promise {<resolved: "success">}
  5. promise2, Promise {<rejected: Error: error!!!>}  
解析：
首先会打印出promise1，但是promise1中有个定时器，此时还并未执行resolve，因此会处于pending状态。
promise2是由promise1执行结束后再执行的，因为promise1还未执行完毕，因此promise2也处于pending状态。
等到定时器一秒后，promise执行了resolve('success')，promise状态变为fulfilled。此时执行promise2，
但是在promise2内抛出一个Error，因此控制台会打印出Error的内容。
等到2秒钟后，第二个定时器触发，直接输出promise1，
此时promise状态已经变为fulfilled，不会再更改，因此输出{'success'}。
promise2状态已经变为rejected，其内容就为Error: error!!!
```

```题目
const ADD_COLUMN_URL = "/pc/addColumn";
function* loadUI() {
  console.log("show loading");
  yield* postAction();
  console.log("hide loading");
}

function *postAction(){
  let postUrl = yield ADD_COLUMN_URL;
  let postData = yield Object.create(null);
  const result = yield request(postUrl,postData);
  if(result.success){
    alert("添加成功！");
  }else{
    alert("失败！");
  }
}

function request(url,data){
  fetch(url,data).then(res => res.json())
  .then(data => {
    load.next(data)
  })
}

const load = loadUI();
load.next();
/**
 * todo
 * 实现新增列
 * 新增数据为{name:"还款日期"}
**/

问：实现todo需求，以下选项正确的有？【多选】
A.
load.next();
load.next({name:"还款日期"});

B.
load.next(ADD_COLUMN_URL);
load.next({name:"还款日期"});

C.
load.next();
load.next({name:"还款日期"});

D.
load.next().next({name:"还款日期"});

答案：B、C
解析：因为Generator.prototype.return会直接返回
done为true,value为return后面的参数，并会中断后面的操作，所以A错误；next方法返回的是一个普通对象{value:ADD_COLUMN_URL,done:false}而不是迭代器，因此不能.next.next连续使用，所以D错误。
并且中断后续的操作。
```

```题目
按要求导出 ES6 模块，以下选项中b.js写法正确的有？
//a.js
import { age } from './b'
console.log(age) // 18

//b.js

A.
export const age = 18

B.
const age = 18;
export age;

C.
const age = 18;
export { age };

D.
export default { age: 18 };
答案：A、C
解析：export default只能导出变量、方法、类，因此D错误。
```

