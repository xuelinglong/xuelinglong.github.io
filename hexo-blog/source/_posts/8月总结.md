---
title: '8月总结[react为主]'
date: 2018-8-29 20:45:39
tags: 月度总结
---

# 8月总结

自4月份入职以后花费时间适应公司的工作一直忽视了写总结，从本月起要至少每月一篇总结，对近期工作、学习、生活有个回顾。

## react

### state

* state可以理解为组件的局部状态。
* render中可以使用this.state.xxx使用state中到值。
* 使用类构造函数constructor初始化状态this.state。
* state的改变需要使用this.setState()。

```
export default class PublicTabbar extends Component {
  constructor(props) {
    super(props);
    this.state = {
      selected: 'topics'
    }
  }
  changeSelected(val) {
    this.setState({
      selected: val
    })
  }
}
```

<!-- more -->

### props

* props可以理解为组件接收的参数，props可以用来显示在dom元素中。
* props一般情况下是父组件向子组件传递。

```
class App extends Component {
  render() {
    return (
      <BrowserRouter>
      <div className="App">
        // 父组件中传递props
        <PublicHeader name={this.state.title}/>
      </div>
      </BrowserRouter>
    );
  }
}
export default class PublicHeader extends Component {
  render() {
    return(
      // 子组件中通过this.props.name获取值
      <header className="PublicHeader">{this.props.name}</header>
    );
  }
}
```

* props中传递事件

```
  changeChild(data){
    this.setState({
      selected: data
    })
  }
  render() {
    return (
      <BrowserRouter>
      <div className="App">
        // 父组件中获取子组件传递的callBack事件
        <PublicTabbar callBack={this.changeChild.bind(this)} />
      </div>
      </BrowserRouter>
    );
  }

export default class PublicTabbar extends Component {
  constructor(props) {
    super(props);
    this.state = {
      selected: 'topics'
    }
  }
  changeSelected(val) {
    this.setState({
      selected: val
    },()=>{
      // 子组件中向父组件传递props事件
      this.props.callBack(this.state.selected)
    })
  }
}
```

### 生命周期

* 总的来说react的生命周期分为三个阶段：挂载、更新、卸载。

挂载(Mounting)：从组件创建到插入真实的 DOM 中。
更新(Updating)：修改组件重新进行渲染。
卸载(Unmounting)：把组件从 DOM 中删除。

#### 挂载阶段

* constructor()在组件创建阶段调用，且从父组件接收props：constructor(props)。
* componentWillMount() 在组件即将挂载时调用。
* render() 组件渲染至 DOM。
* componentDidMount() 在组件挂载完成时调用。

#### 更新阶段

* componentWillReceiveProps(nextPorps) 父组件更新时引起子组件的更新。
  > nextPorps 父组件更新后，传入的新props
* shouldComponentUpdate(nextProps,nextState) 组件的 state 或者 props 发生更新时调用，判断是否更新组件：
  > nextProps 要更新的新props
  > nextState 要更新的新state
  > shouldComponentUpdate中必须定义返回值：return false，则中断更新过程,避免组件重新渲染；return true 则继续执行componentWillUpdate() 和 render()
* componentWillUpdate(nextProps,nextState) 组件即将更新。
* render() 更新组件，重新渲染 DOM。
* componentDidUpdate(prevProps,PrevState) 组件完成更新。

父组件更新引起子组件更新经历的生命周期：父组件componentDidMount -> 子组件componentWillReceiveProps(nextPorps) -> shouldComponentUpdate(nextProps,nextState) -> componentWillUpdate(nextProps,nextState) -> render() -> componentDidUpdate(prevProps,PrevState)

组件自身更新的生命周期：shouldComponentUpdate(nextProps,nextState) -> componentWillUpdate(nextProps,nextState) -> render() -> componentDidUpdate(prevProps,PrevState)

#### 卸载阶段

* compontentWillUnmount() 组件即将被卸载。

### 绑定点击事件

react通过在DOM元素上面使用onClick={funName}绑定事件。特殊的是funName()不会默认绑定this，但我们可以通过bind为方法绑定this和传入参数，如：
```
export default class PublicMenu extends Component {
  constructor(props) {
    super(props);
    this.state = {
      selected: "all"
    }
  }

  changeSelected(val) {
    this.setState({
      selected: val
    },()=>{
      this.props.menuChange(this.state.selected)
    })
  }
  render() {
    return(
      <div onClick={this.changeSelected.bind(this, "all")}>全部</div>
      <div onClick={this.changeSelected.bind(this, "good")}>精华</div>
    );
  }
}
```

### 条件渲染

react使用if或者条件运算符达到条件渲染。

* if

```
  render() {
    const isShow = false
    let tabbar = null
    if(isShow) {
      tabbar = <PublicHeader name={this.state.title}/>
    } else {
      tabbar = console.log(111)
    }
    return (
      <BrowserRouter>
      <div className="App">
        {tabbar}
      </div>
      </BrowserRouter>
    );
  }
```

* &&运算符

原理： true && expression返回expression，false && expression返回false。

```
render() {
  const isShow = false
  return (
    <BrowserRouter>
    <div className="App">
      {isShow && <PublicHeader name={this.state.title}/>}
    </div>
    </BrowserRouter>
  );
}
```

* 三目运算符

```
render() {
  const isShow = false
  return (
    <BrowserRouter>
    <div className="App">
      {isShow ? (<PublicHeader name={this.state.title}/>) : (console.log(111))}
    </div>
    </BrowserRouter>
  );
}
```

### 列表渲染

* 使用map

```
render() {
  const list = [1,2,3,4]
  return (
    <BrowserRouter>
    <div className="App">
      {list.map((number,index) => <span key={index}>{number}</span>)}
      <Main tab={this.state.tab} />
      <PublicTabbar callBack={this.changeChild.bind(this)} />
    </div>
    </BrowserRouter>
  );
}
```

### 状态提升

有时一个状态需要在多个兄弟组件中使用，并且需要保持同步，这种情况下的解决方案：把数据源放在最近的公共父组件中，以props传递给子组件，就会保持同步。

场景：

* 子组件tabbar中有selected来控制选中的样式，点击不同的item切换selected；
* 子组件header需要根据selected的值显示不同的title文字；

错误示例：

* tabbar中定义组件内部状态selected，点击事件中传递props事件到app中，回调函数中改变app的局部状态selected，并把app中的局部状态selected通过props传递给header。

```
// tabbar
export default class PublicTabbar extends Component {
  constructor(props) {
    super(props);
    this.state = {
      selected: 'topics'
    }
  }

  changeSelected(val) {
    this.setState({
      selected: val
    },()=>{
      this.props.callBack(this.state.selected)
    })
  }

  render() {
    return(
      <footer className="PublicTabbar">
        <NavLink className="TabbarItem" to="/">
          <div className={"TabbarItem " + (this.props.selected === 'topics' ? 'selected' : '')} onClick={this.changeSelected.bind(this, 'topics')} >主题</div>
        </NavLink>
        <NavLink className="TabbarItem" to="/message">
          <div className={"TabbarItem " + (this.props.selected === 'message' ? 'selected' : '')} onClick={this.changeSelected.bind(this, 'message')}>消息</div>
        </NavLink>
      </footer>
    );
  }
}
// app
class App extends Component {
  constructor(props){
    super(props);
    this.state = {
      selected: 'topics',
      title: "首页"
    }
  }
  changeChild(data){
    this.setState({
      selected: data
    }, () => {
      if(this.state.selected === 'topics') {
        this.setState({
          title: "首页"
        })
      } else if(this.state.selected === 'message') {
        this.setState({
          title: "消息"
        })
      }
    });
  }
  render() {
    return (
      <BrowserRouter>
      <div className="App">
        <PublicHeader name={this.state.title}/>
        <PublicTabbar callBack={this.changeChild.bind(this)} />
      </div>
      </BrowserRouter>
    );
  }
}
// header
export default class PublicHeader extends Component {
  constructor(props) {
    super(props);
  }
  render() {
    return(
      <header className="PublicHeader">{this.props.name}</header>
    );
  }
}
```

正确示例：

```
// app
class App extends Component {
  constructor(props){
    super(props);
    this.state = {
      selected: 'topics',
      title: "首页"
    }
  }
  changeChild(data){
    this.setState({
      selected: data
    }, () => {
      if(this.state.selected === 'topics') {
        this.setState({
          title: "首页"
        })
      } else if(this.state.selected === 'message') {
        this.setState({
          title: "消息"
        })
      }
    });
  }
  render() {
    return (
      <BrowserRouter>
      <div className="App">
        <PublicHeader name={this.state.title}/>
        <PublicTabbar callBack={this.changeChild.bind(this)} selected={this.state.selected} />
      </div>
      </BrowserRouter>
    );
  }
}
// tabbar
export default class PublicTabbar extends Component {
  constructor(props) {
    super(props);
  }
  changeSelected(val) {
    this.props.callBack(val)
  }
  render() {
    return(
      <footer className="PublicTabbar">
        <NavLink className="TabbarItem" to="/">
          <div className={"TabbarItem " + (this.props.selected === 'topics' ? 'selected' : '')} onClick={this.changeSelected.bind(this, 'topics')} >主题</div>
        </NavLink>
        <NavLink className="TabbarItem" to="/message">
          <div className={"TabbarItem " + (this.props.selected === 'message' ? 'selected' : '')} onClick={this.changeSelected.bind(this, 'message')}>消息</div>
        </NavLink>
      </footer>
    );
  }
}
// header
export default class PublicHeader extends Component {
  constructor(props) {
    super(props);
  }
  render() {
    return(
      <header className="PublicHeader">{this.props.name}</header>
    );
  }
}
```

## router

* BrowserRouter - hostory路由：/calendar/today
* HashRouter - hash路由：#/calendar/today
* link - 可访问的路由链接：`<Link to="/about">About</Link>`
* NavLink - 一个特殊版本的Link，它会在与当前 URL 匹配时为其呈现元素添加样式属性：

```
<NavLink to="/faq" activeClassName="selected">FAQs</NavLink>
```

* Prompt - 位置跳转之前绑定事件：

```
<Prompt message={location => {
  const isApp = location.pathname.startsWith('/app');
  return isApp ? `你确定要跳转到${location.pathname}吗？` : true;
}} />
```

* Route - 定义路由对应关系：`<Route exact path='/' component={Home}/>`
* Router - 所有 Router 组件的通用低阶接口，全局应只有一个：

```
<Router history={history}><App /></Router>
```

* Switch - 用于渲染与路径匹配的第一个子Route或Redirect：

```
<Switch>
  <Route exact path="/" component={Home} />
  <Route path="/about" component={About} />
  <Route path="/:user" component={User} />
  <Route component={NoMatch} />
</Switch>
```

## redux(目前学习进度不多)

我的理解是redux是为了管理项目中的公共状态，并且定义了一系列改变公共状态的方法。

发起action -> reducer接收action与state,并返回新的state

* action：是一个JavaScript对象，用于描述变化。

```
{ type: 'ADD_TODO', text: 'Go to swimming pool' }
```

* reducer：接收action与state，并返回新的state，达到更改state的目的。

```
const changeTitle = (state = {}, action)=> {
  switch(action.type) {
    case type.CHANGE_TITLE:
      // {}是保证不直接修改state,新建一个副本并把源对象复制到state中。
      return Object.assign({}, state, {
        title: action.title
      })
    // default的情况下返回旧的state
    default:
      return state;
  }
}
```

## 工作状态

近期工作中主要开发的是jquery有关的项目，从进公司之后接到的主流项目基本都是jquery的，react的至今只能在别人的项目基础上进行小的需求更改之类的，Vue的可以编写新项目和项目中大的改动，随着公司规定之后新项目的启动只能使用react，我现在才真正意识到react的学习变得很迫切。

近期分配好了KPI任务：Vue公共组件的封装，在进行KPI任务的过程中发现自己的Vue还有很多地方不清楚，所以也在边写边弥补。前两周开发任务不多，但个人效率太低，基本所有时间都花费在Vue组件之上了，但是目前仅仅封装了2个基础组件。

今日总结发现自身问题在于效率太低，时间利用率太低，在公司闲暇时间不能尽可能多的学习或者进行个人任务，下班之后的学习时间又不能有意识的控制，9月要主动控制自己、改掉这些坏习惯。

## 生活状态

近期生活中有点懒散，锻炼也不积极了，晚上回家之后玩的时间太久，只有kpi要过会汇报任务或者工作任务很重的时候才会在家里自主学习或者加班赶进度，其余时间没有利用起来。

