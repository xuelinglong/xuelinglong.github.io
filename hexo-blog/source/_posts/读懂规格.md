---
title: 读懂规格
date: 2017-05-27 23:29:05
tags:
---

ECMA国际标准组织的官方网站：
www.ecma-international.org/ecma-262/6.0/

# 二. 相等运算符
相等运算符（==）：相等运算符用于比较两个值，返回true或false。

1. 如果x不是正常值（比如抛出一个错误），中断执行。
2. 如果y不是正常值，中断执行。
3. 如果Type(x)与Type(y)相同，执行严格相等运算x === y。
4. 如果x是null，y是undefined，返回true。
5. 如果x是undefined，y是null，返回true。
6. 如果Type(x)是数值，Type(y)是字符串，返回x == ToNumber(y)的结果。
7. 如果Type(x)是字符串，Type(y)是数值，返回ToNumber(x) == y的结果。
8. 如果Type(x)是布尔值，返回ToNumber(x) == y的结果。
9. 如果Type(y)是布尔值，返回x == ToNumber(y)的结果。
10. 如果Type(x)是字符串或数值或Symbol值，Type(y)是对象，返回x == ToPrimitive(y)的结果。
11. 如果Type(x)是对象，Type(y)是字符串或数值或Symbol值，返回ToPrimitive(x) == y的结果。
12. 返回false。

` 0 == null // false `
<!-- more -->
# 三. 数组的空位
` const a1 = [undefined, undefined, undefined];
const a2 = [, , ,];  `
数组a1的成员是三个undefined，数组a2的成员是三个空位。
这两个数组很相似，长度都是3，每个位置的成员读取出来都是undefined。

数组的空位会反映在length属性，也就是说空位有自己的位置，但是这个位置的值是未定义，即这个值是不存在的。
如果一定要读取，结果就是undefined（因为undefined在JavaScript语言中表示不存在）。

` 0 in a1 // true
0 in a2 // false
a1.hasOwnProperty(0) // true
a2.hasOwnProperty(0) // false
Object.keys(a1) // ["0", "1", "2"]
Object.keys(a2) // []
a1.map(n => 1) // [1, 1, 1]
a2.map(n => 1) // [, , ,] `
in运算符、数组的hasOwnProperty方法、Object.keys方法，都取不到空位的属性名是因为这个属性名根本就不存在，规格里面没说要为空位分配属性名(位置索引），只说要为下一个元素的位置索引加1。

# 四. 数组的map方法
1. 得到当前数组的this对象
2. 如果报错就返回
3. 求出当前数组的length属性
4. 如果报错就返回
5. 如果map方法的参数callbackfn不可执行，就报错
6. 如果map方法的参数之中，指定了this，就让T等于该参数，否则T为undefined
7. 生成一个新的数组A，跟当前数组的length属性保持一致
8. 如果报错就返回
9. 设定k等于0
10. 只要k小于当前数组的length属性，就重复下面步骤
    a. 设定Pk等于ToString(k)，即将K转为字符串
    b. 设定kPresent等于HasProperty(O, Pk)，即求当前数组有没有指定属性
    c. 如果报错就返回
    d. 如果kPresent等于true，则进行下面步骤
        d-1. 设定kValue等于Get(O, Pk)，取出当前数组的指定属性
        d-2. 如果报错就返回
        d-3. 设定mappedValue等于Call(callbackfn, T, «kValue, k, O»)，即执行回调函数
        d-4. 如果报错就返回
        d-5. 设定status等于CreateDataPropertyOrThrow (A, Pk, mappedValue)，即将回调函数的值放入A数组的指定位置
        d-6. 如果报错就返回
    e. k增加1
11. 返回A

当处理一个全是空位的数组时，前面步骤都没有问题。进入第10步的b时，kpresent会报错，因为空位对应的属性名，对于数组来说是不存在的，因此就会返回，不会进行后面的步骤。

` const arr = [, , ,];
arr.map(n => {
  console.log(n);
  return 1;
}) // [, , ,] `
上面代码中，arr是一个全是空位的数组，map方法遍历成员时，发现是空位，就直接跳过，不会进入回调函数。因此，回调函数里面的console.log语句根本不会执行，整个map方法返回一个全是空位的新数组。
