---
title: '2018-02-13'
date: 2018-02-13 21:59:03
tags: 学习总结
---

年前最后两日进行一下知识回顾梳理，目的在于解决之前项目中所发现的问题和弥补目前已知的知识欠缺的地方。

# 问题及思考
## axios获取数据时使用 isloading、isError两个变量控制
变量解析：

| name | describe | type : init value | change |
| :--- | :------- | :---------------- | :----- |
| nextPage | 下一页 | number : 1 | 加载成功时改变 |
| page | 当前页数 | number: 0 | 加载成功时+1 |
| limit | 每页条数 | number: 20 | 不变 |
| isLoading | 是否正在加载 | boolean : false | 滑动到底部时变为true，loadmore函数结束时再变为false |
| isError | 是否加载失败 | boolean : false | loadmore函数执行时加载失败后变为true,下次开始执行loadmore时变为false |
| noMoreData | 没有更多数据 | boolean : false | loadmore加载数据< limit 时变为true |
<!-- more -->

满足*page < nextPage*的条件才会从API中获取数据，会有获取成功、获取失败两种情况，因此在写项目时要把这些情况都考虑到，设置不同的处理方法。加载成功时当前页数+1，若此次加载数< limit 则nextPage不变同时把noMoreData变为true，若此次加载数 等于 limit 则nextpage加1，加载失败时isError变为false，并提加载失败。

## 记录cookie的原理和实现方法
* cookie是以键值对key=value的形式保存的，各个cookie之间一般是以“;”分隔。
* cookie是存在有效期的，一般情况下cookie生命周期在浏览器关闭时结束，想要cookie在浏览器关闭后还可以使用，就需要为coookie设置有效期。通过expires来设置 cookie 的有效期。` document.cookie = "name=value;expires=date" ` date使用的是GTM（格林威治时间）格式，生成方式如下：
```
// 通过new生成一个Date的实例，得到当前的时间
let exp = new Date()

// setDate()方法来设置时间：getDate()方法得到当前本地月份中的某一天，希望能保存30天所以加上30；
exp.setDate(exp.getDate()+30)

// 用toGMTString()方法把Date对象转换为字符串
exp.toGMTString()
```

### 实现方法
cookie.js
```
export const setCookie = (name, value, seconds) => {
  seconds = seconds || 0
  let expires = ''
  if (seconds !== 0) {
    let exp = new Date()
    exp.setTime(exp.getTime() + (seconds * 1000))
    expires = ';expires=' + exp.toGMTString()
  }
  document.cookie = name + '=' + escape(value) + expires
}

export const getCookie = (name) => {
  let arr
  let reg = new RegExp('(^| )' + name + '=([^;]*)(;|$)')
  if (arr === document.cookie.match(reg)) {
    return unescape(arr[2])
  } else {
    return null
  }
}

export const delCookie = (name) => {
  let exp = new Date()
  exp.setTime(exp.getTime() - 1)
  let cval = getCookie(name)
  if (cval !== null) {
    document.cookie = name + '=' + cval + ';expires=' + exp.toGMTString()
  }
}

```

### 使用方法
```
// 登录时使用
setCookie('accesstoken', payload.accesstoken)

// user页面中使用，放在created()中即可
getcookie('accesstoken')
```

# 概念理解与思考
## 不同组件之间通信
### 父子组件通信
#### 父传子
示例：父组件Topics、子组件TopicsItem
* 父组件中通过 v-bind:data="data" 把值传递给子组件
```
<template>
  <div class="Topics">
    <topics-item :topic="topic"></topics-item>
  </div>
</template>

<script>
import TopicsItem from './TopicsItem'
export default {
  name: 'Topics',
  components: {
    'topics-item': TopicsItem
  }
}
</script>
```

* 子组件这种通过props接收父组件传递过来的值，接受过来的值可以像data中定义的数据那样使用
```
<script>
export default {
  name: 'TopicsItem',
  props: {
    topic: {
      type: Object
    }
  }
}
</script>
```

#### 子传父
示例 父组件parent、子组件child
* 子组件中通过点击事件中的 $emit方法触发一个自定义事件
```
<template>
  <div class="Child">
    <button @click="sendMsgToParent">send Msg</button>
  </div>
</template>

<script>
export default {
  name: 'Child',
  methods: {
    sendMsgToParent () {
      this.$emit('listenChildEvent', 'msg from child')
    }
  }
}
</script>
```

* 父组件中 v-on 来监听子组件触发的事件
```
<template>
  <div class="Parent">
    <child v-on="showMsgFromChild"></child>
  </div>
</template>

<script>
import Child from './Child'
export default {
  name: 'Parent',
  components: {
    'child': Child
  },
  methods: {
    showMsgFromChild (msg) {
      console.log(msg)
    }
  }
}
</script>
```

### 非父子组件之间的通信
示例：firstChild、secondChild
* 使用一个空的VUE实例eventBus作为事件总线
```
var eventBus = new Vue()
```

* firstChild中通过 eventBus.$emit方法传递
```
<template>
  <div class="firstChild">
    <button @click="sendMsgToSecondChild">发送</button>
  </div>
</template>

<script>
import eventBus from './eventBus'
export default {
  name: 'firstChild',
  methods: {
    sendMsgToSecondChild () {
      eventBus.$emit('sendMsg', 'msg from firstChild')
    }
  }
}
</script>
```

* secondChild中 在创建组件的钩子中 通过eventBus.$on监听
```
<template>
  <div class="secondChild">
    <span>{{ message }}</button>
  </div>
</template>

<script>
import eventBus from './eventBus'
export default {
  name: 'secondChild',
  data () {
    return {
      message: ''
    }
  },
  mounted() {
    var _this = this
    eventBus.$on('sendMsg', (msg) => {
      console.log('event')
      this.message = msg
    })
  }
}
</script>
```

## 生命周期
Vue 实例从创建到销毁的过程，就是vue实例的生命周期。<br/>
![date.png](http://upload-images.jianshu.io/upload_images/1393082-c81078815be9af4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
* 第一次页面加载时触发 beforeCreate, created, beforeMount, mounted 这几个钩子，data 数据在 created 中可获取到。
* 更新数据时触发 beforeUpdate 和 updated 钩子，且在 beforeUpdate 触发时，数据已更新完毕。
* 销毁完成后，vue不再对组件内元素的改变做出响应。但是原先生成的dom元素还存在，可以理解为执行了destroy操作，后续就不再受vue控制了。

生命周期钩子的一些使用方法：
* beforecreate : 可以在这加个loading事件，在加载实例时触发 
* created : 初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用
* mounted : 挂载元素，获取到DOM节点
* updated : 如果对数据统一处理，在这里写上相应函数
* beforeDestroy : 可以做一个确认停止事件的确认框
* nextTick : 更新数据后立即操作dom


## 组件怎么拆分
分拆组件是利用vue的组件化开发，将复杂的UI和逻辑拆分开来，第一是减小开发难度，第二能够更清晰的组织代码，第三是增加复用。
* 将组件尽可能的细分，便于复用和优化。
* 尽量使拆分后的组件更容易判断是否更新。


## 状态管理
* 集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。
* 此种方式下集中存储的是*全局通用*且*状态持久*的数据，此类状态的变更都会留下记录。
* 此外，每个实例/组件仍然可以拥有和管理自己的私有状态。
* 适用于多个组件共享状态，如果应用比较简单，不建议使用vuex。

vuex的状态自管理应用包含以下几部分：
* state：驱动应用的数据源；
* view：以声明方式将 state 映射到视图；
* actions：响应在 view 上的用户输入导致的状态变化。

vuex的store对象中包含：
* state：放置数据；
* mutations：状态变更的方法；
* actions：提交mutations来变更状态；
* getters：从store中的state派生出一些状态，相当于store的计算属性，是基于它们的依赖进行缓存的，只有当它的依赖之发生了变化才会被重新计算。


## 双向绑定怎么实现
* 依赖ES5的Object.defineProperty方法构成的观察者模式(订阅发布模式|Pub/Sub)
* 类似AngularJS的脏值检查模式

vue使用的是Object.defineProperty方法构成的观察者模式(订阅发布模式|Pub/Sub)
### 访问器属性
访问器属性是对象中的一种特殊属性，它不能直接在对象中设置，而必须通过 defineProperty() 方法单独定义。访问器属性的"值"比较特殊，读取或设置访问器属性的值，实际上是调用其内部特性：get和set函数。
```
var obj = {}

// 为obj定义一个名为 hello 的访问器属性
Object.defineProperty(obj, "hello", {
  get: function () {return sth},
  set: function (val) {/* do sth */}

})

// 读取属性，就是调用get函数并返回get函数的返回值
obj.hello

// 为属性赋值，就是调用set函数，赋值其实是传参
obj.hello = "abc"
```

get 和 set 方法内部的 this 都指向 obj，这意味着 get 和 set 函数可以操作对象内部的值。另外，访问器属性的会"覆盖"同名的普通属性，因为访问器属性会被优先访问，与其同名的普通属性则会被忽略。

### 实现过程
* 数据 更新 视图
通过Object.defineProperty( )对属性设置一个set函数，当数据改变了就会来触发这个函数，所以我们只要将一些*更新view的方法*放在这里面就可以实现data更新view了。
* 视图 更新 数据
通过*事件监听*

1. 实现一个监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者。
2. 实现一个订阅者Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图。
3. 实现一个解析器Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器。

## MVVM的概念
MVVM是Model-View-ViewModel的简写。
* Model：主要为应用程序提供数据。
* View：还是MVC和MVP中的那个表示层，同时实现UI元素和ViewModel属性的绑定。
* ViewModel：为View提供数据支持。
在MVVM中的Model即有数据属性的定义也有数据访问和处理的行为。ViewModel只有数据属性，一般含有少量逻辑。<br/>

要点：<br/>
![MVVM.png](http://upload-images.jianshu.io/upload_images/1393082-21c5f8000a845731.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)<br/>
1. View持有ViewModel：在View中通过绑定的方式关联UI元素和ViewModel的属性，UI元素的属性变化和ViewMode的数据属性进行双向影响。
2. ViewModel持有Model：Model为ViewModel提供数据支持，同时ViewModel的数据属性变化也会影响Model上，用于数据提交等。
3. 当Model层结束查询或者运算时将结果更新到ViewModel层,ViewModel层因为存在和View的绑定，使得UI层得到通知更新，体现了数据驱动界面的思想。
