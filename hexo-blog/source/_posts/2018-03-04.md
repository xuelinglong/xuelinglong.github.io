---
title: '2018-03-04'
date: 2018-03-04 22:03:12
tags: 学习总结
---

# Actions与async/await

## Generator函数

Generator函数是ES6提供的一种异步编程解决方案。

Generator函数是一个状态机，封存了多个内部状态，执行之后会返回一个<font color=#B22222>遍历器对象</font>，即Generator函数<font color=#B22222>是一个状态机、也是一个遍历器生成函数</font>。返回的<font color=#DB7093>遍历器对象</font>可以<font color=#B22222>遍历Generator函数内部的每一个状态</font>。
<!-- more -->
特征：

1. function关键字与函数名之间有一个<font color=#B22222> * </font>号。
2. 函数体内部使用<font color=#B22222>yield</font>表达式，定义不同的内部状态。
3. 调用方法与普通函数一致，`functionName()`，但是<font color=#B22222>调用Generator函数</font>之后，函数并不执行，<font color=#B22222>返回</font>的并不是函数运行结果，而是<font color=#B22222>一个指向内部状态的指针对象</font>（遍历器对象Iterator Object）。
4. 需要调用遍历器对象的<font color=#DB7093>next</font>方法，才能使得<font color=#B22222>指针移向下一个状态</font>，即每次调用next方法，内部指针就从<font color=#B22222>函数头部</font>或者<font color=#B22222>上一次停下来的地方</font>开始执行，直到遇到<font color=#B22222>下一个yield表达式</font>或者<font color=#B22222>return语句</font>为止。
5. Generator函数是<font color=#DB7093>分段执行</font>的，<font color=#DB7093>yield</font>是<font color=#B22222>暂停执行的标志</font>，而<font color=#DB7093>next方法</font>可以<font color=#B22222>恢复执行</font>。
5. <font color=#DB7093>next方法</font>返回一个有着 <font color=#B22222>value</font> 和 <font color=#B22222>done</font> 两个属性的对象。<font color=#DB7093>value</font>属性表示**当前的内部状态的值**，是**yield表达式后面那个表达式的值**；<font color=#DB7093>done</font>属性是一个**布尔值**，表示**是否遍历结束**。

### yield表达式

Generator函数里面也可以没有yield语句，此时就变成了一个单纯的<font color=#B22222>暂缓执行函数</font>。

遍历器对象的<font color=#DB7093>next</font>方法运行逻辑：

1. 遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。
2. 下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。
3. 如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。
4. 如果该函数没有return语句，则返回的对象的value属性值为undefined。
5. 之后再调用next方法，一直返回`{ value: undefined, done: true }`

注意：

1. yield表达式只能用在Generator函数之内用在其他地方都会报错。
2. yield表达式如果用在另一个表达式之中，必须放在圆括号里面。`function* demo() {console.log('Hello' + (yield 123));}`
3. yield表达式用作函数参数或放在赋值表达式的右边，可以不加括号。

#### yield与return

相似之处：都能返回紧跟在语句后面的表达式的值。
区别：每次遇到yield，函数**暂停执行**，下一次再从该位置继续向后执行。而return语句不具备位置记忆功能，一个函数里面可以执行<font color=#B22222>一个return语句</font>，<font color=#B22222>多个yield</font>。

因为可以有多个yield，因此Generator函数可以返回一系列的值。

### 与Iterator接口的关系
任意一个对象的<font color=#DB7093>Symbol.iterator</font>方法，等于**该对象的遍历器生成函数**，调用该函数会返回**该对象的一个遍历器对象**。

因为Generator函数就是遍历器生成函数，因此把<font color=#DB7093>Generator</font>**赋值给**<font color=#B22222>对象的Symbol.iterator属性</font>，可以使该对象具有Iterator接口，可以被<font color=#B22222>...</font>运算符遍历了。

```
var myIterable = {};
myIterable[Symbol.iterator] = function* () {
  yield 1;
  yield 2;
  yield 3;
};

[...myIterable] // [1, 2, 3]
```

Generator 函数执行后返回一个遍历器对象。该对象本身也具有Symbol.iterator属性，执行后返回<font color=#B22222>自身</font>。

```
function* gen(){
  // some code
}

var g = gen();

g[Symbol.iterator]() === g
```

### next方法的参数

yield表达式本身没有值，或者说总是返回undefined。

1. next方法可以带一个参数，参数会被当作上一个yield表达式的返回值。
2. 通过next方法，可以在Generator函数开始运行之后，继续向函数体内部注入值。即通过next方法，可以在Generator函数运行的不同阶段，从外部向内部注入不同的值，来调整函数行为。
3. next方法的参数表示<font color=#B22222>上一个yield表达式的值</font>，因此在第一次使用的next方法带的参数是**无效**的。从语义上讲，第一个next方法用来启动遍历器对象，所以不需要带有参数。
4. 如果想要第一次next方法就带参数，需要在Generator函数的外部再包一层，

### for...of循环

for...of循环可以**自动遍历** Generator 函数时生成的<font color=#DB7093>Iterator对象</font>，且此时不再需要调用next方法。

注意：一旦next方法的返回对象的<font color=#DB7093>done</font>属性为<font color=#B22222>true</font>，for...of循环就会中止，且**不包含该返回对象**。

```
function* foo() {
  yield 1;
  yield 2;
  return 3;
}

for (let v of foo()) {
  console.log(v);
}
// 1 2
```

<font color=#DB7093>for...of</font>循环、扩展运算符（<font color=#DB7093>...</font>）、<font color=#DB7093>解构赋值</font>和<font color=#DB7093>Array.from</font>方法内部调用的，都是遍历器接口。即它们都可以将 Generator 函数返回的 Iterator 对象，作为参数。

### Generator.prototype.throw()

Generator函数返回的遍历器对象，都有一个<font color=#DB7093>throw</font>方法，可以在函数体内部<font color=#B22222>抛出错误</font>，然后在 Generator 函数体内捕获。

throw方法可以接受一个参数，该参数会被<font color=#DB7093>catch</font>语句接收，建议抛出<font color=#DB7093>Error对象的实例</font>。

* 如果 Generator 函数内部没有部署try...catch代码块，那么throw方法抛出的错误，将被外部try...catch代码块捕获。
* 如果 Generator 函数内部和外部，都没有部署try...catch代码块，那么程序将报错，直接中断执行。

throw方法被捕获之后，会附带执行一次next方法，即附带执行下一个yield表达式。

### Generator.prototype.return()
Generator函数返回的遍历器对象，有一个<font color=#DB7093>return</font>方法，可以<font color=#B22222>返回给定的值</font>，并且<font color=#B22222>终结遍历Generator函数</font>。

* 如果return方法调用时，提供参数，则返回值的<font color=#DB7093>value</font>属性为<font color=#B22222>提供的参数</font>
如果return方法调用时，不提供参数，则返回值的<font color=#DB7093>value</font>属性为<font color=#B22222>undefined</font>，<font color=#DB7093>done</font>属性为<font color=#B22222>true</font>。
* 如果 Generator 函数内部有<font color=#DB7093>try...finally</font>代码块，那么<font color=#DB7093>return</font>方法会推迟到<font color=#B22222>finally</font>代码块执行完再执行。并且调用完return方法之后会立即开始执行<font color=#B22222>finally代码块</font>，finally代码块执行完毕后再执行<font color=#B22222>return</font>方法。


## async函数

async函数使得异步操作变得更加方便，它有以下几个特点：

1. 内置执行器，即async函数可以像普通函数那样执行：`asyncReadFile()`。
2. async表示函数内存在异步操作，<font color=#DB7093>await</font>表示紧跟在后面的表达式需要等待结果。
3. async函数的<font color=#DB7093>await</font>命令后面，可以是 <font color=#B22222>Promise</font> 对象和<font color=#B22222>原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）</font>。
4. async函数的<font color=#B22222>返回值是Promise</font>，我们可以用<font color=#B22222>then</font>方法指定下一步的操作。
5. async函数可以看作是<font color=#B22222>多个异步操作包装成的一个Promise对象</font>，await命令就是内部then命令的语法糖。

## actions与async/await

在我的[vue-CNode项目](https://github.com/xuelinglong/vue-CNode)中使用[node中文社区]的API，登录时使用accesstoken，登录的mutation完成后需要**触发获取用户数据的action**，这就是我遇到的<font color=#DB7093>组合actions</font>情况，此时观看[vuex官方文档action章节](https://vuex.vuejs.org/zh-cn/actions.html)学习组合action的内容，理解如下：

* action通常是异步的，我们可以组合多个action，以处理更加复杂的异步流程。
* <font color=#DB7093>action的处理函数</font>返回一个<font color=#B22222>Promise</font>。
* <font color=#DB7093>store.dispatch</font>可以处理<font color=#DC143C>action的处理函数返回的Promise</font>。
* <font color=#DB7093>store.dispatch</font>仍旧<font color=#DC143C>返回Promise</font>。

以登录操作为例：登录 --> 获取用户数据 / 获取用户收藏的主题，这是异步操作，有先后顺序之分，登陆成功后以获取到的loginname为参数执行下面的获取用户数据和用户收藏的主题，使用async/await：

```
const actions = {
    async [type.LOGIN_USER](context) {
        try {
            const res = await axios.post('accesstoken', {
                accesstoken: 'af0a22ca-d49f-47ec-afef-51b9cabf4c3c'
            });
            await context.commit(type.LOGIN_USER, {
                data: res.data
            });
            await context.dispatch(type.FETCH_USERDATA, {
                loginname: res.data.loginname
            });
            await context.dispatch(type.FETCH_TOPIC_COLLECT, {
                loginname: res.data.loginname
            });
        } catch (err) {
            console.log(err);
        }
    }
}
```

注意：一个 <font color=#DB7093>store.dispatch</font> 在<font color=#DC143C>不同模块中</font>可以<font color=#DC143C>触发多个 action</font> 函数。在这种情况下，只有<font color=#DC143C>当所有触发函数完成后，返回的 Promise 才会执行</font>。

# vuex推荐的action写法

之前我的做法是用**常量**替代**Mutation的事件类型**，action函数名与Mutation事件类型一致，都为常量，但是现在思考发现mutation是同步函数，action可以通过组合来实现异步操作，那么action并不会单纯的只对应一个mutation，即有时一个action里面可以触发别的action，此种情况下我们还是把一个完整的操作写成一个action比较好，从函数名就能看出此action是做什么的。

以上面提到的登陆操作为例：

```
const actions = {
    async loginUser(context) {
        try {
            const res = await axios.post('accesstoken', {
                accesstoken: 'af0a22ca-d49f-47ec-afef-51b9cabf4c3c'
            });
            await context.commit(type.LOGIN_USER, {
                data: res.data
            });
            await context.dispatch('fetchUserData', {
                loginname: res.data.loginname
            });
            await context.dispatch('fetchUserCollectedTopic', {
                loginname: res.data.loginname
            });
        } catch (err) {
            console.log(err);
        }
    }
}

// 组件中触发action
this.$store.dispatch('loginUser');
```
