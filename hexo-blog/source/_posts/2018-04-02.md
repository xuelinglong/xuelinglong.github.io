---
title: '2018-04-02'
date: 2018-04-02 14:15:04
tags: 学习总结
---
# 知识总结

## vue react区别与联系

两者都是javascript UI框架，并且都是只有框架的骨架，路由、状态管理等功能都是框架分离的组件，也都使用了虚拟DOM（它的诞生是为了解决改变真实的DOM状态比改变一个JavaScript对象的花销要大的多），都支持组件化应用。

虚拟DOM：是DOM树的虚拟表现，是一个映射真实DOM的JavaScript对象，要改变元素状态，先在虚拟DOM上面更改，创建一个新的虚拟DOM并且计算出新旧虚拟DOM的差别，之后再把这些差别应用在真实DOM上面。

区别：react使用JSX（允许开发者在JavaScript里面写HTML代码），Vue使用模版系统（Vue的模版基于纯HTML，就是组件中的template）；
<!-- more -->

## 路由钩子

路由钩子是用来在路由跳转前、跳转后、进入/离开某个路由前后监听路由的变化以做操作的。
全局的路由钩子有两个：

```全局导航钩子
router.beforeEach((to, from, next) => {
  // 会在任意路由跳转前执行，next一定要执行，否则路由不能跳转
  console.log('beforeEach')
  console.log(to, from)
  next()
})

router.afterEach((to, from) => {
  console.log('afterEach')
})
```

单个路由钩子：

```单个导航钩子
routes: [
    {
      path: '/foo',
      component: Foo,
      beforeEnter: (to, from, next) => {
        // 在进入前执行，to参数就是当前路由
        // ...
      }
    }
  ]
```

路由组件钩子：

```路由组件钩子
beforeRouteEnter (to, from, next) {
  // 在渲染该组件的对应路由被 confirm 前调用
  // 不！能！获取组件实例 `this`
  // 因为当守卫执行前，组件实例还没被创建
},
beforeRouteUpdate (to, from, next) {
  // 在当前路由改变，但是该组件被复用时调用
  // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
  // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
  // 可以访问组件实例 `this`
},
beforeRouteLeave (to, from, next) {
  // 导航离开该组件的对应路由时调用
  // 可以访问组件实例 `this`
}
```

## 嵌套路由

app.vue里面的router-view是最顶层的出口(渲染最高级路由匹配到的组件)，一个被渲染组件中可以包含自己的嵌套router-view，则需要配合着在routes里面使用children配置，示例：

```嵌套路由示例
// user里面嵌套
<template>
  <div class="user">
    <h1>{{ user.params.id }}</h1>
    <router-view></router-view>
  </div>
</template>
// routes里面配置children
routes: [
  {
    path: '/user/:id',
    name: 'user',
    component: User,
    children: [
      {
        path: 'profile',
        name: 'userProfile',
        component: UserProfile
      },
      {
        path: 'posts',
        name: 'userPosts',
        component: UserPosts
      }
    ]
  }
]
```

## 动态路由匹配

动态路由匹配就是把某种模式匹配到的所有路由映射到同一个组件，可以通过在路由路径中使用<font color=#B22222>动态路径参数</font>来实现。

```动态路由匹配示例
<template>
  <div class="topicItem">
    <router-link :to="{name: 'details', params: {id: topic.id}">
      <div class="topicItem-style">{{ topic.title }}</div>
    </router-link>
  </div>
</template>

routes: [
  {
    path: 'details/:id',
    name: 'details',
    component: Details
  }
]

<template>
  <div class="details">
    <p>{{ $route.params.id }}
  </div>
</template>
```

## v-show和v-if

v-show：元素一直存在，通过切换元素的CSS属性display来显示或者隐藏。  
v-if：为false时DOM树上无此元素，通过操作DOM来删除/添加页面的DOM元素。可以和v-else-if、v-else配合使用，且能添加在template元素上面，渲染结果将不包含template元素。

## vue-loader

vue-loader是一个webpack的loader，可以将template+script+style类型的Vue组件转换为javaScript模块。  
它支持ES6，允许style使用Sass、template使用Jade等，即允许vue组件的组成部分使用其他的webpack的loader；对每个组件模拟出CSS作用域。

## 组件通信

父传子：父组件v-bind:data="data"传递值，子组件props获取值，获取到的值可以像data中定义的数据那样使用。
子传父：子组件$emit触发自定义事件，父组件v-on监听子组件触发的事件。
非父子：定义一个空的Vue实例eventBus，第一个组件中通过eventBus.$emit传递，第二个组件创建组件的钩子中通过eventBus.$on监听。

## 生命周期

八大生命周期：

beforeCreate：可添加loading事件
created：此时data已经初始化了，可结束loading事件，调用异步请求
beforeMount
mounted：挂载元素，获取到DOM节点
beforeUpdate
updated
beforeDestroy：可写一个确认停止时间的确认框
destroyed

## 双向绑定：订阅者模式

observer（监听）：对vue示例的data对象中的所有属性重写getter/setter，使用Object.defineproperty。
Dep（订阅器）：getter中可触发addsub动作向Dep中添加订阅者，setter可触发notify通知Watcher。
Watcher（观察者）：view视图与Model层连接的通道，视图变化时通知data改变，data变化时通知Directive更新。
Directive：使用不同的方法更改不同指令的更新。

## 图片懒加载预加载概念、使用场景...

懒加载：即为延迟加载，在符合条件时才加载。此种方式会减轻服务器前端压力。
预加载：即为提前加载，当用户需要查看时可直接从本地缓存中渲染。此种方式会加大服务器前端压力。

## 跨域

同源需满足：域名相同 + 协议相同 + 端口相同。只要有一个不同浏览器就会阻止跨域操作。

* 单项跨域：新建img、script、iframe、link元素，通过src,href属性设置目标url实现跨域请求。
* 内部服务器代理请求url，vue是配置proxyTable
* JSONP：网页中添加一个`<script>`元素，向服务器请求JSON数据，服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。

## map filter reduce

三个函数的参数都是一个回调函数，并且都会对数组中的每一个元素执行回调函数，map和filter返回一个新的数组，但是map返回的数组包含所有元素执行回调函数之后的结果即使存在undefined，filter返回的数组包含执行回调函数测试之后成功的元素，reduce返回的是函数累计处理的结果（callback的第一个参数是累加器，第二个参数是当前正在处理的元素）。

## 函数作用域和块级作用域

{}就是一个语句块。

ES5和ES6中的函数作用域的概念是一样的：创建函数后在花括号中声明的变量只能在当前函数中起作用，不论变量是通过var、let、const哪个声明的都不能在函数外访问。

块级作用域是ES6提出来的：在语句块中声明的变量只在当前语句块起作用，一般指if(...){...};while{...}...这些语句形成的语句块，且变量只能通过let、const声明（否则就不是块级作用域了），保证了外部不能访问语句块中的变量。

## var、let、const

var：存在变量提升，变量声明提升到顶部，顶部到变量声明语句结束前访问变量得到undefined。  
let：也存在变量提升，变量声明提升到顶部，但是顶部到变量声明结束前访问会报错。  
const：使用const声明的变量其实是对该值的只读引用，使用const声明的原始数据类型声明后就不能再改变，使用const声明的对象可以改变对象的属性值但是不可以给该对象赋值。

## 箭头函数与普通函数

若箭头函数的返回值只有一个表达式可以省略{}，若返回一个对象字面量则需写成：`() => ({foo: bar})`

箭头函数没有自己的this值，它的this值继承于外围作用域；箭头函数也不会获取它们的arguments对象。

arguments对象：是一个对应于传递给函数的类数组对象（只有length和索引，没有数组的方法），是在所有非箭头函数中都可以使用的，假如说给普通函数传递了三个参数，那么可以通过argumentd[0]来引用。typeof arguments返回'Object'，可以使用索引确定单个参数的类型typeof arguments[0]。

把arguments转换为真实的数组：`var arr = Array.prototype.slice.call(arguments)`


## this
全局作用域下：浏览器中执行console.log(this)返回window；node中console.log(this)返回global。

纯粹的函数调用：普通函数调用如test()，指向全局变量，浏览器中window，node中global。  
严格模式：严格模式下执行如test()类型的函数调用，undefined。  
作为对象的方法调用：函数是对象中的一个方法，调用函数，this指向这个对象。

做构造函数使用：有new时指向new出来的对象，没有new时指向window。

## 前端缓存

cookie：存储容量小4k以内，在网络请求时可发送，不建议存储重要数据。
LocalStorage：html5的本地缓存方案，如果不手动清除，数据永远不会过期。
SessionStorage：本地缓存，关闭浏览器时清除数据。

## js定义函数

* 函数声明表达式：`function name(params){...}`
* function操作符：`var xxx = function [name可选](params){...}`
* Function构造函数：`new Function([参数,参数],functionBody)`
* 箭头函数：(param) => { statements }

## http状态码

* 1xx：消息
* 2xx：成功
> 202：服务器已接受请求，但尚未处理
> 204：服务器成功处理了请求，没有返回任何内容
* 3xx：重定向
> 301: 重定向  
> 302：临时重定向  
* 4xx：客户端错误
> 404：请求的资源不存在  
* 5xx：服务器端错误

## javaScript数据存储

栈（stack）：后进先出，存储基础数据类型（Number、String、Null、Undefined、Boolean）、按值访问、存储的值大小固定、系统自动分配存储空间、主要用来执行程序、空间小运行效率高。  
堆（heap）：无序存储可根据引用直接获取、存储引用数据类型（Array、Object、函数）、按引用访问、存储的值大小不固定可动态调整、程序员代码分配空间、主要用来存放对象、空间大运行效率低。

引用数据类型的值是保存在堆内存中的对象，我们操作不能直接操作对象的堆内存空间，实际上我们操作的是对象的引用，引用的含义是保存在栈内存中的一个地址，该地址与堆内存中实际值相关联。

访问堆内存中的引用数据类型时需要先访问存储在栈内存中的该对象的地址引用（或地址指针），然后再从堆内存中取出数据。

JavaScript内存生命周期：分配所需内存；使用分配到的内存（读、写）；不需要时释放归还内存。

## 闭包

定义：闭包是指有权访问另一个函数作用域中的变量的函数。  
创建闭包的最常用方法：在一个函数内创建另一个函数，通过另一个函数访问这个函数内的局部变量。
闭包的使用场合：设计私有的方法和变量。  
闭包的缺点：常驻内存，会增大内存使用量，使用不当易造成内存泄露。  
闭包的好处：避免全局变量的污染；私有成员的存在；希望一个变量常驻内存中。

闭包的特性：
* 函数嵌套函数
* 函数内部可以引用外部的参数和变量
* 参数和变量不会被垃圾回收机制回收

闭包的常见用途：
* 创建特权方法用于访问控制
* 事件处理程序及回调

## 更改this的方法

* call：接受两个参数，第一个参数obj绑定this的值，后面接受的是不定参数。
* apply：接受两个参数，第一个参数obj绑定this的值，第二个是一个参数数组。
* bind：接受一个参数obj，绑定this的值。

## 去除字符串中的空格
* trim方法可以去掉字符串首尾的空格
* replace方法可以去掉所有空格

## 数组去重的方法 冒泡->indexOf->filter
1. 可以使用冒泡排序，然后再依次对比相邻元素是否相等，相等的话通过数组的splice方法删除一个。
2. 因为使用冒泡排序太麻烦，所以可以使用sort排序再通过splice方法删除。
3. 先排序再遍历删除重复元素还是太麻烦，因此可以使用indexOf查看值在新数组中是否存在，如果不存在则push进去。
4. filter的测试函数结合indexOf可以更好的实现去重。
5. 最方便的当然是使用ES6中的Set或者Map实现去重了。


## 反转数组
1. for循环反转数组，定义一个新数组，for循环反向遍历原数组，依次push元素到新数组中。
2. pop+push实现反转数组，定义一个新数组，使用pop方法依次删除原数组尾部元素，然后使用pop依次把push方法返回的被删除元素添加到新数组尾部。
3. shift+unshift实现反转数组，定义一个新数组，使用shift方法依次删除原数组头部元素，然后使用unshift依次把shift方法返回的被删除元素添加到新数组头部。
4. 最便捷的还是使用reverse方法反转数组。

## 取出数组最大值
1. for循环取最大值，定义一个变量，依次与数组内元素做对比，小于数组中元素时把该元素赋值给变量。
2. 排序（冒泡、快排）按照从大到小的顺序，然后取第一个元素。
3. Math.max方法可以取数组中的最大值。

## webpack、转移速度慢时怎么办
webpack是一个JavaScript应用程序的静态模块打包器，webpack本身只能识别JavaScript，但是webpack的loader可以将所有非js类型的文件转化为webpack能够处理的模块。

## 盒子模型！！！！！

盒模型是元素大小的呈现方式，由content、padding、border、margin组成。
IE下的盒子模型：width包含border、padding，content部分包含padding、border。
w3c标准盒模型：width/height仅止content部分的width/height，盒子大小由content、padding、border决定。
怪异模型（box-sizing：border-box）：width/height是content+padding+border，盒子大小由width和height决定。

## 闭包和匿名函数的关系

匿名函数：就是没有名字的函数。  
闭包：函数中定义的子函数。

匿名函数的最大用途就是创建闭包，并且可以构建命名空间，减少全局变量的使用。

## 立即执行函数

立即执行函数通常是指声明完之后立即执行的函数，这类函数通常不需要名字，只是函数的一种调用方式，如：

```立即执行函数
(function() {
  console.log('你好)
})()
```

立即执行的匿名函数并不是函数，因为已经执行过了，所以它是一个结果，这个结果是对当前这个匿名函数执行结果的一个引用。

## 深拷贝、浅拷贝

深拷贝和浅拷贝只是针对Object和Array这样的复杂类型的。

浅拷贝：将a赋值给b，但是改变b时a也会被改变，意味着a和b其实指向同一个内存，这就是浅拷贝。  
深拷贝：把b放在新内存里，把a的属性全部复制（包括属性的子属性）到b中，之后a与b相互独立，这就是深拷贝。

## Dom事件模型

Dom事件模型包含四方面的内容：事件流、主浏览器的事件模型、事件对象、注册与移除事件监听器。

事件流：html元素产生一个事件时，该元素节点与根节点之间的路径上所经过的节点都会收到这个事件，这个传播过程就叫做事件流。  
JavaScript的时间流主要经历三个阶段：事件捕获、目标出发、时间冒泡(有的不经过冒泡阶段)。

DOM标准的事件处理模型有冒泡型事件和捕获型事件两种。  
冒泡型事件：DOM树上理解是事件从叶子结点沿祖先节点一直向上传递直到根节点；浏览器视图html元素排列层次上理解是从具有从属关系的最确定元素一直传递到最不确定的目标元素。  
捕获型事件：由DOM树最顶层元素一直到最精确的元素。  
DOM标准事件模型支持这两种事件模型，可以说是它们两个的结合体。

事件对象：IE中事件对象是window的event属性，在标准的DOM浏览器中事件对象包含在target中。  
注册与移除事件监听器：

注册与移除事件监听器：DOM标准的浏览器中通过元素的addEventListener方法注册（注：此方法支持冒泡型和捕获型的事件处理）。移除监听器调用element的removeEventListener方法。以上两个方法都是三个参数：1.事件名称，2.回调处理函数observer，3.注明处理函数是在那个阶段被调用，true为捕获阶段。

## get、post

get与post都是使用http的方法。

get获取数据很安全，不会改变数据源，并且对同一URL的多个请求返回同样的结果，get请求的数据放在URL之后，以？分割URL和传输数据，参数之间以&连接，get提交的数据是有大小限制的，拼接起来是完整的URL，因此不能大于浏览器及服务器对URL长度的限制。  
post可能修改数据源，post把提交的数据放在http包的包体中，post提交的数据是没有大小限制的主要看服务器的处理能力。

用途：get主要用来从服务获取数据，post主要用于向服务器提交数据。

## 双向绑定缺点

单向绑定是单向数据流，所有数据的变化都可以被记录和跟踪，状态变化需要手动操作，可以追寻源头，便于维护。缺点是代码量大、数据的流转过程变长。
双向绑定的优点是在表单交互等场景下会简化大量的代码量。缺点是都是“暗箱操作”，无法追踪局部状态，若组件数据变化来源不止一个时容易弄混数据流。

## 翻转二叉树

主要思想是二叉树存在的话交换当前节点的左右分支，然后判断左右子树是否存在，存在的话在递归左右分支的节点。

## DOM重绘、重排

重绘重排都是浏览器上面的行为，重绘不一定引起重排，重排一定会引起重绘。

重绘的情况有：元素背景色改变，不会带来渲染树的改变时就是重绘。
重排的情况有：布局的改变，元素几何属性的改变，元素内容的变化，删除已经渲染过的元素，DOM树结构变化（增减、移动节点等），浏览器窗口尺寸的变化等。

## 居中

水平居中：

1. 行内元素：text-align=center
2. 固定宽度的块状元素：margin: 0 auto;
3. 不定宽度的块状元素：父元素position：relative，子元素position：absolute、left：50%、transform：translateX（-50%）;第二种方案：父元素text-align：center，子元素display：inline。
4. flex实现水平居中：父元素display：flex、justify-content：center。

垂直居中：

1. 父元素高度确定的单行文本：line-height=height。
2. 父元素高度确定的多行文本：display：table-cell，vertical-align：middle。
3. flex布局实现垂直居中：父元素display：flex、align-items：center。


## 浏览器内核

渲染引擎：获取网页内容并整理讯息，计算网页的显示方式，输出至显示器或打印机。
js引擎：解析和执行JS来实现网页的动态效果。

## src与href的区别

src：指向外部资源的位置，浏览器解析到该元素使会暂停对其他资源的处理，直至把该外部资源加载、编译、执行完毕，即把指定内容嵌入到文档当前标签所在位置。

href：指向网络资源的所在位置，建立和当前文档或当前元素的链接，浏览器会并行下载资源且不会停止对当前文档的处理。

## 页面中有大量图片时如何优化

1. 页面未可是区域内的图片做成懒加载。
2. ppt、幻灯片等可做成预加载，优先加载当前显示图片的前一张与后一张。
3. 图片过大时可采用特殊编码的图片，先加载一张压缩特别厉害的压缩图，提高用户体验。
4. 若图片显示位置小于原图片大小，应在服务器端先根据需要把图片压缩至与位置大小相同再显示。

## html语义化

根据内容结构，选择合适的标签，便于开发者阅读和写出更优雅的代码同时，便于浏览器的解析。

必要性：

1. 有利于SEO，有助于爬虫获取更多的有效信息，爬虫是根据标签来确定上下文和各个关键字的权重的。
2. 语义话的html在没有CSS的情况下也能呈现较好的内容结构与代码结构。

## 搜索引擎优化SEO

1. 语义化的html代码。
2. 重要内容的html代码放前面，搜索引擎抓去是从上到下的，要保证重要内容一定会被抓取到。
3. 重要内容不要用js输出。
4. 非装饰性图片一定要加alt。
5. 合理的title、description、keywords，这三个权重依次减小，title放前面且不同页面title要不同。


## doctype

`<!DOCTYPE html>`写在html标签之前，告诉浏览器当前HTML版本。

## img标签的title和alt

title：为图片添加相关信息，在鼠标滑动到图片上时显示。
alt：图片内容的等价描述，是img特有的属性，用于图片无法加载显示、读屏器阅读图片，除了纯装饰的图片外都必须设置有意义的值，搜索引擎会重点分析。

## 数据类型

基本数据类型：undefined、null、NaN、Number、String、Boolean、Symbol(ES6)  
复杂数据类型：Object  
object又可分为三个子类型：数组、狭义的对象、函数  

## 遍历

1. 简单的for循环
2. for...in：遍历key，返回所有<font color=#B22222>可枚举属性</font>。
3. for...of：遍历value，循环Array、Map、Set、String、TypedArray、arguments的可迭代属性，且在循环中忽略不可迭代属性。
4. filter：可遍历数组，接受一个函数为参数，返回一个包含所有执行回调函数时值为true的原数组元素的数组。
5. forEach：对数组中的每一个元素执行回调函数，forEach对空数组无效，且忽略数组中被删除或者未初始化的项，不支持continue,break,return。
6. map：返回一个包含所有元素执行回调函数后返回的结果的新数组，只有数组中有值的元素才会执行回调函数。

## 数组的方法

* push：将一个或者多个元素添加到数组的末尾，返回值为新数组的长度。
* unshift：将一个或多个元素添加到数组的头部，返回值为新数组的长度。
* concat：用于合并两个或者多个数组，不修改现有数组，返回一个新数组。
* slice：拷贝数组从开始到结束（不包含结束）的元素，返回一个新数组。
* shift：删除数组中的第一个元素，返回该元素的值，会更改数组的长度。
* pop：删除数组中的最后一个元素，返回该元素的值，会更改数组长度。
* splice：通过删除现有元素 / 添加新元素 来更改数组内容，返回由被删除元素组成的数组。
* indexOf：查找给定元素的第一个索引，返回索引值，如果没找到则返回-1。
* join：将一个数组或者类数组对象的所有元素拼接为字符串，参数是分隔符，空参数默认分隔符为‘,’ ，返回值为字符串。
* find：找到满足回调函数测试的第一个元素的值，并返回这个元素值，若未找到则返回undefined。
* findIndex：找到满足回调函数测试的第一个元素的索引，并返回这个元素的索引，若未找到则返回-1。

## 字符串的方法

* concat：连接一个或多个字符串
* indexOf：可以从左到右查找字符串中给定值的第一个索引，可以使用第二个参数指定开始查找位置，没找到则返回-1。区分大小写
* lastIndexOf：可以查找字符串中给定值的最后一个索引，可以使用第二个参数指定开始查找位置，没找到则返回-1。区分大小写
* slice：复制字符串的一部分。
* substr：返回字符串中给定位置到指定字符数的字符，可用来提取或者拷贝子字符串。
* substring：返回一个开始索引到结束索引（不包含）的字符串子集。
* split：把字符串分割为数组，不给参数则每个字符都分割。
* trim：删除字符串首尾的空白字符（tab、空格、space等）。
* search：参数是一个正则表达式，返回在字符串中首次匹配项的索引，否则返回-1。

## Object的常用方法

* Object.toString()：返回一个表示该对象的字符串。
* Object.assign(target, obj)：拷贝源对象中所有的可枚举属性到目标对象中，返回值为目标对象。第一个参数是目标对象，第二个参数是源对象。浅拷贝：具有相同键时源属性值覆盖目标属性值。
* Object.entries(obj)：返回一个给定对象自身可枚举属性的键值对数组。
* Object.keys(obj)：返回一个由一个给定对象的自身可枚举属性组成的数组。
* Object.hasOwnProperty('name')：判断自身是否具有指定的属性。


## DOM

为了<font color=#B22222>操作文档</font>出现了一个API为DOM（文档对象模型）：页面中的整个文档、文档头部、里面的div等都是文档所属的DOM的一部分。我们可以通过JavaScript来访问和操作存储在DOM中的内容。

整个HTMl文档可以看作是一个对象树（DOM树），div等标签都可看作是一个对象，每个对象又称为一个<font color=#B22222>节点</font>，我们可以使用document、window等元素的API来操作DOM。

## document

浏览器下载到一个网页通常是HTML，这个HTMl就是document（这也是DOM树当中的一个节点node），document通常是DOM树的根节点，它包含了title、URL等属性，我们可以在JS中直接访问到。

注：document是DOM的一个对象。

常用的document属性：

* document.title：返回当前文档的标题。
* document.URL：返回当前文档的url。
* document.getElementByID()：返回对拥有指定ID的第一个对象的引用。
* document.getElementsByName()：返回带有指定名称的对象的集合。
* document.getElementsByClassName()：返回文档中所有指定类名的元素集合，作为**NodeList对象集合**（类似于数组的数据结构，但是仅仅提供了length属性，没有提供数组中的push、pop等方法）。

## window

为了操作浏览器诞生了一个API为BOM（浏览器对象模型），而window就是BOM的一个对象，通过window我们可以获取窗口位置、确定窗口大小、弹出对话框、关闭当前窗口等。

常用的window属性：

* 地址栏属性location：location.href可以获取和修改当前地址栏的URL信息。
* 历史记录属性history：history.forward()相当于浏览器的前进按钮；history.backward()相当于浏览器的后退按钮；history.go()前进或后退，正数前进，负数后退，0表示自己。
* 浏览器版本信息属性navigator：navigaror.userAgent获取当前浏览器的版本信息。
