<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Vue.js," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="什么是组件（Component）？组件可以扩展 HTML 元素，封装可重用的代码。在较高层面上，组件是自定义元素， Vue.js 的编译器为它添加特殊功能。在有些情况下，组件也可以是原生 HTML 元素的形式，以 is 特性扩展。 使用组件注册可以通过以下方式创建一个 Vue 实例：1234new Vue(&amp;#123;  el: &amp;apos;#xxxx&amp;apos;,  // 选项&amp;#125;) 使">
<meta name="keywords" content="Vue.js">
<meta property="og:type" content="article">
<meta property="og:title" content="Vue-组件">
<meta property="og:url" content="http://yoursite.com/2017/06/10/Vue-组件/index.html">
<meta property="og:site_name" content="Vue">
<meta property="og:description" content="什么是组件（Component）？组件可以扩展 HTML 元素，封装可重用的代码。在较高层面上，组件是自定义元素， Vue.js 的编译器为它添加特殊功能。在有些情况下，组件也可以是原生 HTML 元素的形式，以 is 特性扩展。 使用组件注册可以通过以下方式创建一个 Vue 实例：1234new Vue(&amp;#123;  el: &amp;apos;#xxxx&amp;apos;,  // 选项&amp;#125;) 使">
<meta property="og:updated_time" content="2017-06-25T01:19:46.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Vue-组件">
<meta name="twitter:description" content="什么是组件（Component）？组件可以扩展 HTML 元素，封装可重用的代码。在较高层面上，组件是自定义元素， Vue.js 的编译器为它添加特殊功能。在有些情况下，组件也可以是原生 HTML 元素的形式，以 is 特性扩展。 使用组件注册可以通过以下方式创建一个 Vue 实例：1234new Vue(&amp;#123;  el: &amp;apos;#xxxx&amp;apos;,  // 选项&amp;#125;) 使">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/06/10/Vue-组件/"/>





  <title>Vue-组件 | Vue</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Vue</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/10/Vue-组件/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xue Ling">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Vue">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Vue-组件</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-10T22:53:15+08:00">
                2017-06-10
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/06/10/Vue-组件/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/06/10/Vue-组件/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="什么是组件（Component）？"><a href="#什么是组件（Component）？" class="headerlink" title="什么是组件（Component）？"></a>什么是组件（Component）？</h1><p>组件可以扩展 HTML 元素，封装可重用的代码。在较高层面上，组件是自定义元素， Vue.js 的编译器为它添加特殊功能。在有些情况下，组件也可以是原生 HTML 元素的形式，以 is 特性扩展。</p>
<h1 id="使用组件"><a href="#使用组件" class="headerlink" title="使用组件"></a>使用组件</h1><h2 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h2><p>可以通过以下方式创建一个 Vue 实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">new Vue(&#123;</div><div class="line">  el: &apos;#xxxx&apos;,</div><div class="line">  // 选项</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>使用Vue.component(tagName, options)注册一个<strong>全局组件</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Vue.component(&apos;my-component&apos;, &#123;</div><div class="line">  // 选项</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>对于自定义标签名，Vue.js 不强制要求遵循 W3C规则（小写，并且包含一个短杠），尽管遵循这个规则比较好。<br><a id="more"></a><br>组件在注册之后，便可以在父实例的模块中以自定义元素 <code>&lt;my-component&gt;&lt;/my-component&gt;</code>的形式使用。</p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;example&quot;&gt;</div><div class="line">    &lt;!-- #example 是Vue实例挂载的元素，应该在挂载元素范围内使用组件--&gt;   </div><div class="line">    &lt;my-component&gt;&lt;/my-component&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;script&gt;</div><div class="line">    //1.注册组件，并制定组件的HTML标签：此处为my-component</div><div class="line">    Vue.component(&apos;my-component&apos;,&#123;</div><div class="line">        template: &apos;&lt;div&gt;This is my first component!&lt;/div&gt;&apos;</div><div class="line">    &#125;)</div><div class="line">    //2.创建根实例</div><div class="line">    new Vue(&#123;</div><div class="line">        el: &apos;#example&apos;</div><div class="line">    &#125;)</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>渲染为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;example&quot;&gt;</div><div class="line">    &lt;div&gt;This is my first component!&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p><strong>注意：要确保在初始化根实例 之前 注册了组件。</strong></p>
<h2 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h2><p>通过使用组件实例选项注册，可以使组件仅在另一个实例<strong>/</strong>组件的作用域中可用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;example-1&quot;&gt;</div><div class="line">    &lt;!--  my-component1 只能在#example-1下使用--&gt;   </div><div class="line">    &lt;my-component1&gt;&lt;/my-component1&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;script&gt;</div><div class="line">    var Child=&#123;</div><div class="line">        template: &apos;&lt;div&gt;This is my second component!&lt;/div&gt;&apos;</div><div class="line">    &#125;</div><div class="line">    new Vue(&#123;</div><div class="line">        el: &apos;#example-1&apos;,</div><div class="line">        components:&#123;</div><div class="line">            // 将myComponent1 组件注册到Vue实例下</div><div class="line">            &apos;my-component1&apos;: Child</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>这种封装也适用于其它可注册的 Vue 功能，如指令。</p>
<h2 id="注册语法糖"><a href="#注册语法糖" class="headerlink" title="注册语法糖"></a>注册语法糖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//在一个步骤中扩展与注册</div><div class="line">Vue.component(&apos;my-component&apos;, &#123;</div><div class="line">  template: &apos;&lt;div&gt;A custom component!&lt;/div&gt;&apos;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">// 局部注册也可以这么做</div><div class="line">    &lt;script&gt;</div><div class="line">        // var Child=&#123;</div><div class="line">        //     template: &apos;&lt;div&gt;This is my second component!&lt;/div&gt;&apos;</div><div class="line">        // &#125;</div><div class="line">        // new Vue(&#123;</div><div class="line">        //     el: &apos;#example-1&apos;,</div><div class="line">        //     components:&#123;</div><div class="line">        //         // 将myComponent1 组件注册到Vue实例下</div><div class="line">        //         &apos;my-component1&apos;: Child</div><div class="line">        //     &#125;</div><div class="line">        // &#125;)</div><div class="line">        //等同于：</div><div class="line">        new Vue(&#123;</div><div class="line">            el: &apos;#example-1&apos;,</div><div class="line">            components:&#123;</div><div class="line">                // 将myComponent1 组件注册到Vue实例下</div><div class="line">                &apos;my-component1&apos;: &#123;</div><div class="line">                    template: &apos;&lt;div&gt;This is my second component!&lt;/div&gt;&apos;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">    &lt;/script&gt;</div></pre></td></tr></table></figure>
<h2 id="DOM模版解析说明"><a href="#DOM模版解析说明" class="headerlink" title="DOM模版解析说明"></a>DOM模版解析说明</h2><p>当使用 DOM 作为模版时（例如，将 el 选项挂载到一个已存在的元素上）, 你会受到 HTML 的一些限制，因为 Vue 只有在浏览器解析和标准化 HTML 后才能获取模版内容。尤其像这些元素 <code>&lt;ul&gt; ，&lt;ol&gt;，&lt;table&gt; ，&lt;select&gt;</code>限制了能被它包裹的元素， 而一些像<code>&lt;option&gt;</code> 这样的元素只能出现在某些其它元素内部。<br>在自定义组件中使用这些受限制的元素时会导致一些问题，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;table&gt;</div><div class="line">  &lt;my-row&gt;...&lt;/my-row&gt;</div><div class="line">&lt;/table&gt;</div></pre></td></tr></table></figure></p>
<p>自定义组件<code>&lt;my-row&gt;</code>被认为是无效的内容，因此在渲染的时候会导致错误。变通的方案是使用特殊的 is 属性：<br>一些 HTML 元素，如<code>&lt;table&gt;</code>，限制什么元素可以放在它里面。自定义元素不在白名单上，将被放在元素的外面，因而渲染不正确。这时应当使用 is 特性，指示它是一个自定义元素：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;table&gt;</div><div class="line">  &lt;tr is=&quot;my-row&quot;&gt;&lt;/tr&gt;</div><div class="line">&lt;/table&gt;</div></pre></td></tr></table></figure></p>
<p><strong>注意：当使用来自以下来源之一的字符串模板，这些限制将不适用：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/x-template&quot;&gt;</div><div class="line">JavaScript内联模版字符串</div><div class="line">.vue 组件</div></pre></td></tr></table></figure></p>
<p>因此，有必要的话请使用字符串模版。</p>
<h2 id="data必须是函数"><a href="#data必须是函数" class="headerlink" title="data必须是函数"></a>data必须是函数</h2><p>通过Vue构造器传入的各种选项大多数都可以在组件里用。</p>
<p>data 是一个例外，它必须是函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&lt;!--组建中使用data时：data必须是函数--&gt;</div><div class="line">&lt;div id=&quot;example-4&quot;&gt;</div><div class="line">    &lt;simple-counter&gt;&lt;/simple-counter&gt;</div><div class="line">    &lt;simple-counter&gt;&lt;/simple-counter&gt;</div><div class="line">    &lt;simple-counter&gt;&lt;/simple-counter&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;script&gt;</div><div class="line">    var data = &#123; counter: 0 &#125;</div><div class="line">    Vue.component(&apos;simple-counter&apos;, &#123;</div><div class="line">        template: &apos;&lt;button v-on:click=&quot;counter += 1&quot;&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;&apos;,</div><div class="line">        // 技术上 data 的确是一个函数了，因此 Vue 不会警告，</div><div class="line">        // 但是我们返回给每个组件的实例的却引用了同一个data对象</div><div class="line">        // data: function () &#123;</div><div class="line">        //     return data      //增加一个counter会影响所有组件</div><div class="line">        // &#125;</div><div class="line">        data: function () &#123;</div><div class="line">            return &#123;</div><div class="line">                counter: 0      //每个 counter 都有它自己内部的状态</div><div class="line">            &#125; </div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">    new Vue(&#123;</div><div class="line">        el: &apos;#example-4&apos;</div><div class="line">    &#125;)</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<h2 id="构成组件"><a href="#构成组件" class="headerlink" title="构成组件"></a>构成组件</h2><p>组件意味着协同工作。<br>通常父子组件会是这样的关系：组件 A 在它的模版中使用了组件 B 。<br>它们之间必然需要相互通信：父组件要给子组件传递数据，子组件需要将它内部发生的事情告知给父组件。</p>
<p>在 Vue.js 中：<br>父子组件的关系可以总结为 props down, events up 。<br>父组件通过 props 向下传递数据给子组件；<br>子组件通过 events 给父组件发送消息。</p>
<h1 id="Prop"><a href="#Prop" class="headerlink" title="Prop"></a>Prop</h1><h2 id="使用Prop传递数据"><a href="#使用Prop传递数据" class="headerlink" title="使用Prop传递数据"></a>使用Prop传递数据</h2><p>组件实例的作用域是<strong>孤立的</strong>。<br>这意味着不能(也不应该)在子组件的模板内直接引用父组件的数据。要让子组件使用父组件的数据，我们需要通过子组件的props选项。<br>子组件要显式地用 props 选项声明它期待获得的数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;prop-example-1&quot;&gt;</div><div class="line">    &lt;!--向子组件传入一个普通字符串--&gt;</div><div class="line">    &lt;child message=&quot;hello!&quot;&gt;&lt;/child&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;script&gt;           </div><div class="line">    new Vue(&#123;</div><div class="line">        el: &apos;#prop-example-1&apos;,</div><div class="line">        components:&#123;</div><div class="line">              child: &#123;</div><div class="line">                    // 声明 props</div><div class="line">                    props: [&apos;message&apos;],</div><div class="line">                    // 就像 data 一样，prop 可以用在模板内</div><div class="line">                    // 同样也可以在 vm 实例中像 “this.message” 这样使用</div><div class="line">                    template: &apos;&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;&apos;</div><div class="line">              &#125;  </div><div class="line">        &#125;</div><div class="line">    &#125;)        </div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<h2 id="camelCase-VS-kebab-case"><a href="#camelCase-VS-kebab-case" class="headerlink" title="camelCase VS kebab-case"></a>camelCase VS kebab-case</h2><p>HTML 特性是不区分大小写的。所以，当使用的不是字符串模版，camelCased (驼峰式) 命名的 prop 需要转换为相对应的 kebab-case (短横线隔开式) 命名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;prop-example-2&quot;&gt;        </div><div class="line">    &lt;input v-model=&quot;parentmsg&quot;&gt;</div><div class="line">    &lt;br&gt;</div><div class="line">    &lt;!--用 v-bind 动态地绑定父组件的数据到子模板的props--&gt;</div><div class="line">                    &lt;!-- kebab-case in HTML --&gt;</div><div class="line">    &lt;child v-bind:my-message=&quot;parentmsg&quot;&gt;&lt;/child&gt;</div><div class="line">    &lt;p&gt;&#123;&#123;parentmsg&#125;&#125;&lt;/p&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;script&gt;           </div><div class="line">    new Vue(&#123;</div><div class="line">        el: &apos;#prop-example-2&apos;,</div><div class="line">        data:&#123;</div><div class="line">            parentmsg: &apos;Message from parent&apos;</div><div class="line">        &#125;,</div><div class="line">        components: &#123;</div><div class="line">            child: &#123;</div><div class="line">                // camelCase in JavaScript</div><div class="line">                props: [&apos;myMessage&apos;],</div><div class="line">                // prop 可以用在模板内</div><div class="line">                // 可以用 `this.msg` 设置</div><div class="line">                template: &apos;&lt;span&gt;&#123;&#123;myMessage&#125;&#125;&lt;/span&gt;&apos;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;)     </div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>如果使用的是字符串模版，则没有这些限制。</p>
<h2 id="动态Prop"><a href="#动态Prop" class="headerlink" title="动态Prop"></a>动态Prop</h2><p>类似于绑定一个普通的特性到一个表达式，也可以用 v-bind 绑定动态 Props 到父组件的数据。每当父组件的数据变化时，也会传导给子组件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;prop-example-2&quot;&gt;        </div><div class="line">    &lt;input v-model=&quot;parentmsg&quot;&gt;</div><div class="line">    &lt;br&gt;</div><div class="line">    &lt;!--用 v-bind 动态地绑定父组件的数据到子模板的props--&gt;</div><div class="line">                    &lt;!-- kebab-case in HTML --&gt;</div><div class="line">    &lt;child v-bind:my-message=&quot;parentmsg&quot;&gt;&lt;/child&gt;</div><div class="line">    &lt;p&gt;&#123;&#123;parentmsg&#125;&#125;&lt;/p&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;script&gt;           </div><div class="line">    new Vue(&#123;</div><div class="line">        el: &apos;#prop-example-2&apos;,</div><div class="line">        data:&#123;</div><div class="line">            parentmsg: &apos;Message from parent&apos;</div><div class="line">        &#125;,</div><div class="line">        components: &#123;</div><div class="line">            child: &#123;</div><div class="line">                // camelCase in JavaScript</div><div class="line">                props: [&apos;myMessage&apos;],</div><div class="line">                // prop 可以用在模板内</div><div class="line">                // 可以用 `this.msg` 设置</div><div class="line">                template: &apos;&lt;span&gt;&#123;&#123;myMessage&#125;&#125;&lt;/span&gt;&apos;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;)     </div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<h2 id="字面量语法-VS-动态语法"><a href="#字面量语法-VS-动态语法" class="headerlink" title="字面量语法 VS 动态语法"></a>字面量语法 VS 动态语法</h2><p>不能使用字面量语法传递数值（下面是<strong>错误</strong>的）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 传递了一个字面 prop ：值是字符串 &quot;1&quot; 而不是number。--&gt;</div><div class="line">&lt;comp some-prop=&quot;1&quot;&gt;&lt;/comp&gt;</div></pre></td></tr></table></figure></p>
<p>如果想传递一个实际的number，需要使用 v-bind ，从而让它的值被当作 JavaScript 表达式计算：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 传递实际的 number --&gt;</div><div class="line">&lt;comp v-bind:some-prop=&quot;1&quot;&gt;&lt;/comp&gt;</div></pre></td></tr></table></figure></p>
<h2 id="单项数据流"><a href="#单项数据流" class="headerlink" title="单项数据流"></a>单项数据流</h2><p>prop 是单向绑定的：即当父组件的属性变化时，将会传导给子组件；但是子组件的属性变化不会传导给父组件。<br>原因：防止子组件无意修改了父组件的状态。</p>
<p>注意：每次父组件更新时，子组件的所有 prop 都会更新为最新值。<br>因此：我们<strong>不能</strong>在子组件内部改变 prop。</p>
<ol>
<li><p>prop 作为初始值传入后，子组件想把它当作局部数据来用。<br>解决办法：<br>定义一个局部变量，并用 prop 的值初始化它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">props: [&apos;initialCounter&apos;],</div><div class="line">data: function () &#123;</div><div class="line">  return &#123; counter: this.initialCounter &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>prop 作为初始值传入，由子组件处理成其它数据输出。<br>解决办法：<br>定义一个计算属性，处理 prop 的值并返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">props: [&apos;size&apos;],</div><div class="line">computed: &#123;</div><div class="line">  normalizedSize: function () &#123;</div><div class="line">    return this.size.trim().toLowerCase()</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>注意在 JavaScript 中对象和数组是引用类型，指向同一个内存空间，如果 prop 是一个对象或数组，在子组件内部改变它<strong>会影响</strong>父组件的状态。</p>
<h2 id="Prop验证"><a href="#Prop验证" class="headerlink" title="Prop验证"></a>Prop验证</h2><p>我们可以为组件的 props 指定验证规格。如果传入的数据不符合规格，Vue 会发出警告。当组件给其他人使用时，这很有用。</p>
<p>要指定验证规格，需要用对象的形式，而不能用字符串数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">Vue.component(&apos;example&apos;, &#123;</div><div class="line">            props: &#123;</div><div class="line">                // 基础类型检测 （`null` 意思是任何类型都可以）</div><div class="line">                propA: Number,</div><div class="line">                // 多种类型</div><div class="line">                propB: [String, Number],</div><div class="line">                // 必传且是字符串</div><div class="line">                propC: &#123;</div><div class="line">                    type: String,</div><div class="line">                    required: true</div><div class="line">                &#125;,</div><div class="line">                // 数字，有默认值</div><div class="line">                propD: &#123;</div><div class="line">                    type: Number,</div><div class="line">                    default: 100</div><div class="line">                &#125;,</div><div class="line">                // 数组／对象的默认值应当由一个工厂函数返回</div><div class="line">                propE: &#123;</div><div class="line">                    type: Object,</div><div class="line">                    default: function () &#123;</div><div class="line">                        return &#123; message: &apos;hello&apos; &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;,</div><div class="line">                // 自定义验证函数</div><div class="line">                propF: &#123;</div><div class="line">                    validator: function (value) &#123;</div><div class="line">                        return value &gt; 10</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;)</div></pre></td></tr></table></figure></p>
<p>type 可以是下面原生构造器：</p>
<ol>
<li>String；</li>
<li>Number；</li>
<li>Boolean；</li>
<li>Function；</li>
<li>Object；</li>
<li>Array；</li>
<li>一个自定义函数，使用 instanceof 检测。</li>
</ol>
<p>当 prop 验证失败，Vue会在抛出警告 (如果使用的是开发版本)。</p>
<h1 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h1><p>父组件是使用 <strong>props</strong> 传递数据给子组件，<br>子组件使用<strong>自定义事件</strong>把数据传递回去。</p>
<h2 id="使用-v-on-绑定自定义事件"><a href="#使用-v-on-绑定自定义事件" class="headerlink" title="使用 v-on 绑定自定义事件"></a>使用 v-on 绑定自定义事件</h2><p>每个vue实例都实现了时间接口，即：</p>
<ol>
<li>使用 <strong><code>$on(eventName)</code></strong>监听事件；</li>
<li><p>使用<strong><code>$emit(eventName)</code></strong>触发事件。</p>
<p><strong>父组件</strong>可以在使用子组件的地方直接<strong>用 v-on</strong> 来<strong>监听子组件触发的事件</strong>。<br>注意：不能用<strong><code>$on</code></strong>侦听子组件抛出的事件，而必须在模板里直接用v-on绑定。</p>
</li>
</ol>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;counter-event-example&quot;&gt;</div><div class="line">    &lt;p&gt;&#123;&#123; total &#125;&#125;&lt;/p&gt;</div><div class="line">    &lt;!--当子组件触发了 &quot;increment&quot; 事件，父组件的 incrementTotal 方法将被调用。--&gt;</div><div class="line">    &lt;button-counter v-on:increment=&quot;incrementTotal&quot;&gt;&lt;/button-counter&gt;</div><div class="line">    &lt;button-counter v-on:increment=&quot;incrementTotal&quot;&gt;&lt;/button-counter&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;script&gt;</div><div class="line">    // 注册子组件button-counter</div><div class="line">    Vue.component(&apos;button-counter&apos;, &#123;</div><div class="line">        //v-on 指令绑定一个事件监听器，通过它调用increment方法</div><div class="line">        template: &apos;&lt;button v-on:click=&quot;increment&quot;&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;&apos;,</div><div class="line">        data: function () &#123;</div><div class="line">            return &#123;</div><div class="line">            counter: 0</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        methods: &#123;</div><div class="line">            increment: function () &#123;</div><div class="line">                this.counter += 1</div><div class="line">                this.$emit(&apos;increment&apos;)</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    new Vue(&#123;</div><div class="line">        el: &apos;#counter-event-example&apos;,</div><div class="line">        data: &#123;</div><div class="line">            total: 0</div><div class="line">        &#125;,</div><div class="line">        methods: &#123;</div><div class="line">            incrementTotal: function () &#123;</div><div class="line">                this.total += 1</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>子组件只是报告自己的内部事件，至于父组件是否关心则与它无关。</p>
<h3 id="给组件绑定原生事件"><a href="#给组件绑定原生事件" class="headerlink" title="给组件绑定原生事件"></a>给组件绑定原生事件</h3><p>使用<strong><code>.native</code></strong>修饰 v-on可以在某个组件的根元素上监听一个原生事件。<br>示例：<br><code>&lt;my-component v-on:click.native=&quot;doTheThing&quot;&gt;&lt;/my-component&gt;</code></p>
<h2 id="sync修饰符-2-3-0"><a href="#sync修饰符-2-3-0" class="headerlink" title=".sync修饰符(2.3.0+)"></a>.sync修饰符(2.3.0+)</h2><p>在 2.0 发布之后的实际应用中，我们发现<strong><code>.sync</code></strong>还是有其适用之处，比如在开发可复用的组件库时。我们需要做的只是<strong>让子组件改变父组件状态的代码更容易被区分</strong>。</p>
<p>在 2.3 我们重新引入了<strong><code>.sync</code></strong>修饰符，但是这次它只是作为一个编译时的语法糖存在。它会被扩展为<strong>一个自动更新父组件属性的 v-on 侦听器</strong>。<br><code>&lt;comp :foo.sync=&quot;bar&quot;&gt;&lt;/comp&gt;</code><br>会被扩展为：<br><code>&lt;comp :foo=&quot;bar&quot; @update:foo=&quot;val =&gt; bar = val&quot;&gt;&lt;/comp&gt;</code><br>当子组件需要更新 foo 的值时，它需要显式地触发一个更新事件：<br><code>this.$emit(&#39;update:foo&#39;, newValue)</code></p>
<h2 id="使用自定义时间的表单输入组件"><a href="#使用自定义时间的表单输入组件" class="headerlink" title="使用自定义时间的表单输入组件"></a>使用自定义时间的表单输入组件</h2><p>自定义事件可以用来创建自定义的表单输入组件，使用 v-model 来进行数据双向绑定。</p>
<p><code>&lt;input v-model=&quot;something&quot;&gt;</code><br>上面代码是以下示例的语法糖：<br><code>&lt;input v-bind:value=&quot;something&quot; v-on:input=&quot;something = $event.target.value&quot;&gt;</code><br>所以在组件中使用时，它相当于下面的简写：<br><code>&lt;custom-input v-bind:value=&quot;something&quot; v-on:input=&quot;something = arguments[0]&quot;&gt;&lt;/custom-input&gt;</code></p>
<p>所以要让组件的 v-model 生效，它必须：</p>
<ol>
<li>接受一个 value 属性；</li>
<li>在有新的 value 时触发 input 事件。</li>
</ol>
<p>事件接口不仅仅可以用来连接组件内部的表单输入，也很容易集成你自己创造的输入类型。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;voice-recognizer v-model=&quot;question&quot;&gt;&lt;/voice-recognizer&gt;</div><div class="line">&lt;webcam-gesture-reader v-model=&quot;gesture&quot;&gt;&lt;/webcam-gesture-reader&gt;</div><div class="line">&lt;webcam-retinal-scanner v-model=&quot;retinalImage&quot;&gt;&lt;/webcam-retinal-scanner&gt;</div></pre></td></tr></table></figure></p>
<h2 id="非父子组件通信"><a href="#非父子组件通信" class="headerlink" title="非父子组件通信"></a>非父子组件通信</h2><p>有时候两个组件也需要通信(非父子关系)。</p>
<p>在简单的场景下，可以使用一个空的 Vue 实例作为中央事件总线：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//定义一个空的 Vue 实例作为中央事件总线</div><div class="line">var bus = new Vue()</div><div class="line"></div><div class="line">// 触发组件 A 中的事件</div><div class="line">bus.$emit(&apos;id-selected&apos;, 1)</div><div class="line"></div><div class="line">// 在组件 B 创建的钩子中监听事件</div><div class="line">bus.$on(&apos;id-selected&apos;, function (id) &#123;</div><div class="line">  // ...</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>在复杂的情况下，我们应该考虑使用专门的<strong>状态管理模式</strong>。</p>
<h1 id="使用Slot分发内容"><a href="#使用Slot分发内容" class="headerlink" title="使用Slot分发内容"></a>使用Slot分发内容</h1><p>在使用组件时，我们常常要像这样组合它们：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;app&gt;</div><div class="line">  &lt;app-header&gt;&lt;/app-header&gt;</div><div class="line">  &lt;app-footer&gt;&lt;/app-footer&gt;</div><div class="line">&lt;/app&gt;</div></pre></td></tr></table></figure></p>
<p>注意：</p>
<ol>
<li><strong><code>&lt;app&gt;</code></strong>组件不知道它的挂载点会有什么内容。挂载点的内容是由<strong><code>&lt;app&gt;</code></strong>的父组件决定的。</li>
<li><strong><code>&lt;app&gt;</code></strong>组件很可能有它自己的模版。</li>
</ol>
<p>为了让组件可以组合，我们需要一种方式来混合父组件的内容与子组件自己的模板。这个过程被称为 <strong>内容分发</strong>。</p>
<p>Vue.js 实现了一个内容分发 API ，参照了当前 Web 组件规范草案，使用特殊的 <strong><code>&lt;slot&gt;</code></strong>元素作为原始内容的插槽。</p>
<h2 id="编译作用域"><a href="#编译作用域" class="headerlink" title="编译作用域"></a>编译作用域</h2><p>假定模板为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;child-component&gt;</div><div class="line">  &#123;&#123; message &#125;&#125;</div><div class="line">&lt;/child-component&gt;</div><div class="line">&lt;!--message 应该绑定到父组件的数据--&gt;</div></pre></td></tr></table></figure></p>
<p>组件作用域简单地说是：<br>父组件模板的内容在父组件作用域内编译；<br>子组件模板的内容在子组件作用域内编译。</p>
<p><strong>错误：</strong>试图在父组件模板内将一个指令绑定到子组件的属性/方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 无效 --&gt;</div><div class="line">&lt;child-component v-show=&quot;someChildProperty&quot;&gt;&lt;/child-component&gt;</div></pre></td></tr></table></figure></p>
<p>如果要绑定作用域内的指令到一个组件的根节点，应当在组件自己的模板上做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Vue.component(&apos;child-component&apos;, &#123;</div><div class="line">  // 有效，因为是在正确的作用域内</div><div class="line">  template: &apos;&lt;div v-show=&quot;someChildProperty&quot;&gt;Child&lt;/div&gt;&apos;,</div><div class="line">  data: function () &#123;</div><div class="line">    return &#123;</div><div class="line">      someChildProperty: true</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>类似地，分发内容是在父作用域内编译。</p>
<h2 id="单个Slot"><a href="#单个Slot" class="headerlink" title="单个Slot"></a>单个Slot</h2><p>除非子组件模板包含至少一个<strong><code>&lt;slot&gt;</code></strong>插口，否则父组件的内容将会被丢弃。当子组件模板只有一个没有属性的 slot 时，父组件整个内容片段将插入到 slot 所在的 DOM 位置，并替换掉 slot 标签本身。</p>
<p>最初在<strong><code>&lt;slot&gt;</code></strong>标签中的任何内容都被视为备用内容。备用内容在子组件的作用域内编译，并且只有在宿主元素为空，且没有要插入的内容时才显示备用内容。<br>示例：<br>假定 my-component 组件有下面模板：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;</div><div class="line">  &lt;h2&gt;我是子组件的标题&lt;/h2&gt;</div><div class="line">  &lt;slot&gt;</div><div class="line">    只有在没有要分发的内容时才会显示。</div><div class="line">  &lt;/slot&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>父组件模版：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;</div><div class="line">  &lt;h1&gt;我是父组件的标题&lt;/h1&gt;</div><div class="line">  &lt;my-component&gt;</div><div class="line">    &lt;p&gt;这是一些初始内容&lt;/p&gt;</div><div class="line">    &lt;p&gt;这是更多的初始内容&lt;/p&gt;</div><div class="line">  &lt;/my-component&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>渲染结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;</div><div class="line">  &lt;h1&gt;我是父组件的标题&lt;/h1&gt;</div><div class="line">  &lt;div&gt;</div><div class="line">    &lt;h2&gt;我是子组件的标题&lt;/h2&gt;</div><div class="line">    &lt;p&gt;这是一些初始内容&lt;/p&gt;</div><div class="line">    &lt;p&gt;这是更多的初始内容&lt;/p&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<h2 id="具名Slot"><a href="#具名Slot" class="headerlink" title="具名Slot"></a>具名Slot</h2><p><strong><code>&lt;slot&gt;</code></strong> 元素可以用一个特殊的属性 name 来配置如何分发内容。<br>多个 slot 可以有不同的名字。<br>具名 slot 将匹配内容片段中有对应 slot 特性的元素。<br>仍然可以有一个匿名 slot ，它是<strong>默认 slot </strong>，作为找不到匹配的内容片段的备用插槽。<br>如果没有默认的 slot ，这些找不到匹配的内容片段将被抛弃。</p>
<p>假定我们有一个 app-layout 组件的模板为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;</div><div class="line">  &lt;slot name=&quot;one&quot;&gt;&lt;/slot&gt;</div><div class="line">  &lt;slot&gt;&lt;/slot&gt;  </div><div class="line">  &lt;slot name=&quot;two&quot;&gt;&lt;/slot&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>父组件模版：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;app-layout&gt;</div><div class="line">  &lt;p slot=&quot;one&quot;&gt;One&lt;/p&gt;</div><div class="line">  &lt;p slot=&quot;two&quot;&gt;Two&lt;/p&gt;</div><div class="line">  &lt;p&gt;Default A&lt;/p&gt;</div><div class="line">&lt;/app-layout&gt;</div></pre></td></tr></table></figure></p>
<p>渲染结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;</div><div class="line">  &lt;p slot=&quot;one&quot;&gt;One&lt;/p&gt;</div><div class="line">  &lt;p&gt;Default A&lt;/p&gt;   </div><div class="line">  &lt;p slot=&quot;two&quot;&gt;Two&lt;/p&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>在组合组件时，内容分发 API 是非常有用的机制。</p>
<h2 id="作用域插槽（2-1-0新增）"><a href="#作用域插槽（2-1-0新增）" class="headerlink" title="作用域插槽（2.1.0新增）"></a>作用域插槽（2.1.0新增）</h2><p>作用域插槽是一种特殊类型的插槽，用作使用一个（能够传递数据到）可重用模板替换已渲染元素。</p>
<p>在子组件中，只需将数据传递到插槽，就像将 prop 传递给组件一样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;child&quot;&gt;</div><div class="line">  &lt;slot text=&quot;hello from child&quot;&gt;&lt;/slot&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>在父级中，具有特殊属性 scope 的<strong><code>&lt;template&gt;</code></strong>元素，表示它是作用域插槽的模板。scope 的值对应一个临时变量名，此变量接收从子组件中传递的 prop 对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;parent&quot;&gt;</div><div class="line">  &lt;child&gt;</div><div class="line">    &lt;template scope=&quot;props&quot;&gt;</div><div class="line">      &lt;span&gt;hello from parent&lt;/span&gt;</div><div class="line">      &lt;span&gt;&#123;&#123; props.text &#125;&#125;&lt;/span&gt;</div><div class="line">    &lt;/template&gt;</div><div class="line">  &lt;/child&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>如果我们渲染以上结果，得到的输出会是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;parent&quot;&gt;</div><div class="line">  &lt;div class=&quot;child&quot;&gt;</div><div class="line">    &lt;span&gt;hello from parent&lt;/span&gt;</div><div class="line">    &lt;span&gt;hello from child&lt;/span&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>作用域插槽更具代表性的用例：<br>列表组件，允许组件自定义应该如何渲染列表每一项：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;my-awesome-list :items=&quot;items&quot;&gt;</div><div class="line">  &lt;!-- 作用域插槽也可以是具名的 --&gt;</div><div class="line">  &lt;template slot=&quot;item&quot; scope=&quot;props&quot;&gt;</div><div class="line">    &lt;li class=&quot;my-fancy-item&quot;&gt;&#123;&#123; props.text &#125;&#125;&lt;/li&gt;</div><div class="line">  &lt;/template&gt;</div><div class="line">&lt;/my-awesome-list&gt;</div></pre></td></tr></table></figure></p>
<p>列表组件的模板：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;ul&gt;</div><div class="line">  &lt;slot name=&quot;item&quot;</div><div class="line">    v-for=&quot;item in items&quot;</div><div class="line">    :text=&quot;item.text&quot;&gt;</div><div class="line">    &lt;!-- 这里写入备用内容 --&gt;</div><div class="line">  &lt;/slot&gt;</div><div class="line">&lt;/ul&gt;</div></pre></td></tr></table></figure></p>
<h1 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h1><p>多个组件可以使用同一个挂载点，并动态地在它们之间切换。使用保留的<strong><code>&lt;component&gt;</code></strong>元素：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var vm = new Vue(&#123;</div><div class="line">  el: &apos;#example&apos;,</div><div class="line">  data: &#123;</div><div class="line">    currentView: &apos;home&apos;</div><div class="line">  &#125;,</div><div class="line">  components: &#123;</div><div class="line">    home: &#123; /* ... */ &#125;,</div><div class="line">    posts: &#123; /* ... */ &#125;,</div><div class="line">    archive: &#123; /* ... */ &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;component v-bind:is=&quot;currentView&quot;&gt;</div><div class="line">  &lt;!-- 组件在 vm.currentview 变化时改变 --&gt;</div><div class="line">&lt;/component&gt;</div></pre></td></tr></table></figure>
<p>也可以直接绑定到组件对象上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var Home = &#123;</div><div class="line">  template: &apos;&lt;p&gt;Welcome home!&lt;/p&gt;&apos;</div><div class="line">&#125;</div><div class="line">var vm = new Vue(&#123;</div><div class="line">  el: &apos;#example&apos;,</div><div class="line">  data: &#123;</div><div class="line">    currentView: Home</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h2 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h2><p>如果把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染。为此可以添加一个 keep-alive 指令参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;keep-alive&gt;</div><div class="line">  &lt;component :is=&quot;currentView&quot;&gt;</div><div class="line">    &lt;!-- 非活动组件将被缓存！ --&gt;</div><div class="line">  &lt;/component&gt;</div><div class="line">&lt;/keep-alive&gt;</div></pre></td></tr></table></figure></p>
<h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><h2 id="编写可复用组件"><a href="#编写可复用组件" class="headerlink" title="编写可复用组件"></a>编写可复用组件</h2><p>在编写组件时，记住是否要复用组件有好处。<br>一次性组件跟其它组件紧密耦合没关系，但是可复用组件应当定义一个清晰的公开接口。</p>
<p>Vue 组件的 API 来自三部分 - props, events 和 slots ：</p>
<ol>
<li>Props 允许外部环境传递数据给组件</li>
<li>Events 允许组件触发外部环境的副作用</li>
<li>Slots 允许外部环境将额外的内容组合在组件中。</li>
</ol>
<p>使用 v-bind 和 v-on 的简写语法，模板的缩进清楚且简洁：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;my-component</div><div class="line">  :foo=&quot;baz&quot;</div><div class="line">  :bar=&quot;qux&quot;</div><div class="line">  @event-a=&quot;doThis&quot;</div><div class="line">  @event-b=&quot;doThat&quot;</div><div class="line">&gt;</div><div class="line">  &lt;img slot=&quot;icon&quot; src=&quot;...&quot;&gt;</div><div class="line">  &lt;p slot=&quot;main-text&quot;&gt;Hello!&lt;/p&gt;</div><div class="line">&lt;/my-component&gt;</div></pre></td></tr></table></figure></p>
<h2 id="子组件索引"><a href="#子组件索引" class="headerlink" title="子组件索引"></a>子组件索引</h2><p>使用 ref 为子组件指定一个索引 ID ，可以在 JavaScript 中直接访问子组件。</p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;parent&quot;&gt;</div><div class="line">  &lt;user-profile ref=&quot;profile&quot;&gt;&lt;/user-profile&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var parent = new Vue(&#123; el: &apos;#parent&apos; &#125;)</div><div class="line">// 访问子组件</div><div class="line">var child = parent.$refs.profile</div></pre></td></tr></table></figure>
<p>当 ref 和 v-for 一起使用时， ref 是一个数组或对象，包含相应的子组件。</p>
<p><strong><code>$refs</code></strong>只在组件渲染完成后才填充，并且它是非响应式的。它仅仅作为一个直接访问子组件的应急方案——应当避免在模版或计算属性中使用<strong><code>$refs</code></strong>。</p>
<h2 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h2><p>在大型应用中，我们可能需要将应用拆分为多个小模块，按需从服务器下载。<br>Vue.js 允许将组件定义为一个工厂函数，动态地解析组件的定义。<br>Vue.js 只在组件需要渲染时触发工厂函数，并且把结果缓存起来，用于后面的再次渲染。<br>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Vue.component(&apos;async-example&apos;, function (resolve, reject) &#123;</div><div class="line">  setTimeout(function () &#123;</div><div class="line">    // Pass the component definition to the resolve callback</div><div class="line">    resolve(&#123;</div><div class="line">      template: &apos;&lt;div&gt;I am async!&lt;/div&gt;&apos;</div><div class="line">    &#125;)</div><div class="line">  &#125;, 1000)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>工厂函数接收一个 resolve 回调，在收到从服务器下载的组件定义时调用。也可以调用 reject(reason) 指示加载失败。</p>
<h2 id="高级异步组件（2-3-0新增）"><a href="#高级异步组件（2-3-0新增）" class="headerlink" title="高级异步组件（2.3.0新增）"></a>高级异步组件（2.3.0新增）</h2><p>异步组件的工厂函数也可以返回一个如下的对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">const AsyncComp = () =&gt; (&#123;</div><div class="line">  // 需要加载的组件. 应当是一个 Promise</div><div class="line">  component: import(&apos;./MyComp.vue&apos;),</div><div class="line">  // loading 时应当渲染的组件</div><div class="line">  loading: LoadingComp,</div><div class="line">  // 出错时渲染的组件</div><div class="line">  error: ErrorComp,</div><div class="line">  // 渲染 loading 组件前的等待时间。默认：200ms.</div><div class="line">  delay: 200,</div><div class="line">  // 最长等待时间。超出此时间则渲染 error 组件。默认：Infinity</div><div class="line">  timeout: 3000</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>若要在路由组件中上述写法，需要使用 vue-router 2.4.0+。</p>
<h2 id="组件命名约定"><a href="#组件命名约定" class="headerlink" title="组件命名约定"></a>组件命名约定</h2><p>当注册组件（或者 props）时，可以使用 kebab-case ，camelCase ，或 TitleCase 。</p>
<p>但在 HTML 模版中，请使用 kebab-case 形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 在HTML模版中始终使用 kebab-case --&gt;</div><div class="line">&lt;kebab-cased-component&gt;&lt;/kebab-cased-component&gt;</div><div class="line">&lt;camel-cased-component&gt;&lt;/camel-cased-component&gt;</div><div class="line">&lt;title-cased-component&gt;&lt;/title-cased-component&gt;</div></pre></td></tr></table></figure></p>
<p>当使用字符串模式时，可以不受限制，即可以使用camelCase 、 TitleCase 或者 kebab-case 来引用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 在字符串模版中可以用任何你喜欢的方式! --&gt;</div><div class="line">&lt;my-component&gt;&lt;/my-component&gt;</div><div class="line">&lt;myComponent&gt;&lt;/myComponent&gt;</div><div class="line">&lt;MyComponent&gt;&lt;/MyComponent&gt;</div></pre></td></tr></table></figure></p>
<p>如果组件未经 slot 元素传递内容，则可以在组件名后使用 / 使其自闭合：<br><code>&lt;my-component/&gt;</code><br>当然，这只在字符串模版中有效。因为自闭的自定义元素是无效的 HTML ，浏览器原生的解析器也无法识别它。</p>
<h2 id="递归组件"><a href="#递归组件" class="headerlink" title="递归组件"></a>递归组件</h2><p>当组件具有 name 选项时才可以在它的模板内可以递归地调用自己：<br><code>name: &#39;unique-name-of-my-component&#39;</code></p>
<p>利用Vue.component全局注册了一个组件, 全局的ID作为组件的 name 选项，被自动设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Vue.component(&apos;unique-name-of-my-component&apos;, &#123;</div><div class="line">  // ...</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>如果不够谨慎, 递归组件可能导致死循环（例如）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">name: &apos;stack-overflow&apos;,</div><div class="line">template: &apos;&lt;div&gt;&lt;stack-overflow&gt;&lt;/stack-overflow&gt;&lt;/div&gt;&apos;</div></pre></td></tr></table></figure></p>
<p>因此：要确保递归调用有终止条件 (比如递归调用时使用 v-if 并让他最终返回 false )。</p>
<h2 id="组件间的循环引用Circular-References-Between-Components"><a href="#组件间的循环引用Circular-References-Between-Components" class="headerlink" title="组件间的循环引用Circular References Between Components"></a>组件间的循环引用Circular References Between Components</h2><p>告诉模块化管理系统循环引用的组件间的处理优先级</p>
<h2 id="内联模板"><a href="#内联模板" class="headerlink" title="内联模板"></a>内联模板</h2><p>如果子组件有 inline-template 特性，组件将把它的内容当作它的模板，而不是把它当作分发内容。这让模板更灵活。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;my-component inline-template&gt;</div><div class="line">  &lt;div&gt;</div><div class="line">    &lt;p&gt;These are compiled as the component&apos;s own template.&lt;/p&gt;</div><div class="line">    &lt;p&gt;Not parent&apos;s transclusion content.&lt;/p&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">&lt;/my-component&gt;</div></pre></td></tr></table></figure></p>
<p>但是 inline-template 让模板的作用域难以理解。最佳实践是使用 template 选项在组件内定义模板或者在 .vue 文件中使用 template 元素。</p>
<h2 id="X-Templates"><a href="#X-Templates" class="headerlink" title="X-Templates"></a>X-Templates</h2><p>另一种<strong>定义模版</strong>的方式是在 JavaScript 标签里使用 text/x-template 类型，并且指定一个id。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/x-template&quot; id=&quot;hello-world-template&quot;&gt;</div><div class="line">  &lt;p&gt;Hello hello hello&lt;/p&gt;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Vue.component(&apos;hello-world&apos;, &#123;</div><div class="line">  template: &apos;#hello-world-template&apos;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Vue-js/" rel="tag"># Vue.js</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/06/09/Vue-表单控件绑定/" rel="next" title="Vue-表单控件绑定">
                <i class="fa fa-chevron-left"></i> Vue-表单控件绑定
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/06/13/Vue-练习/" rel="prev" title="Vue-练习">
                Vue-练习 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Xue Ling" />
          <p class="site-author-name" itemprop="name">Xue Ling</p>
           
              <p class="site-description motion-element" itemprop="description">ES6</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">37</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#什么是组件（Component）？"><span class="nav-number">1.</span> <span class="nav-text">什么是组件（Component）？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#使用组件"><span class="nav-number">2.</span> <span class="nav-text">使用组件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#注册"><span class="nav-number">2.1.</span> <span class="nav-text">注册</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#局部注册"><span class="nav-number">2.2.</span> <span class="nav-text">局部注册</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#注册语法糖"><span class="nav-number">2.3.</span> <span class="nav-text">注册语法糖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DOM模版解析说明"><span class="nav-number">2.4.</span> <span class="nav-text">DOM模版解析说明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#data必须是函数"><span class="nav-number">2.5.</span> <span class="nav-text">data必须是函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构成组件"><span class="nav-number">2.6.</span> <span class="nav-text">构成组件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Prop"><span class="nav-number">3.</span> <span class="nav-text">Prop</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用Prop传递数据"><span class="nav-number">3.1.</span> <span class="nav-text">使用Prop传递数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#camelCase-VS-kebab-case"><span class="nav-number">3.2.</span> <span class="nav-text">camelCase VS kebab-case</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态Prop"><span class="nav-number">3.3.</span> <span class="nav-text">动态Prop</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字面量语法-VS-动态语法"><span class="nav-number">3.4.</span> <span class="nav-text">字面量语法 VS 动态语法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#单项数据流"><span class="nav-number">3.5.</span> <span class="nav-text">单项数据流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Prop验证"><span class="nav-number">3.6.</span> <span class="nav-text">Prop验证</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#自定义事件"><span class="nav-number">4.</span> <span class="nav-text">自定义事件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用-v-on-绑定自定义事件"><span class="nav-number">4.1.</span> <span class="nav-text">使用 v-on 绑定自定义事件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#给组件绑定原生事件"><span class="nav-number">4.1.1.</span> <span class="nav-text">给组件绑定原生事件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sync修饰符-2-3-0"><span class="nav-number">4.2.</span> <span class="nav-text">.sync修饰符(2.3.0+)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用自定义时间的表单输入组件"><span class="nav-number">4.3.</span> <span class="nav-text">使用自定义时间的表单输入组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#非父子组件通信"><span class="nav-number">4.4.</span> <span class="nav-text">非父子组件通信</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#使用Slot分发内容"><span class="nav-number">5.</span> <span class="nav-text">使用Slot分发内容</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#编译作用域"><span class="nav-number">5.1.</span> <span class="nav-text">编译作用域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#单个Slot"><span class="nav-number">5.2.</span> <span class="nav-text">单个Slot</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#具名Slot"><span class="nav-number">5.3.</span> <span class="nav-text">具名Slot</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#作用域插槽（2-1-0新增）"><span class="nav-number">5.4.</span> <span class="nav-text">作用域插槽（2.1.0新增）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#动态组件"><span class="nav-number">6.</span> <span class="nav-text">动态组件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#keep-alive"><span class="nav-number">6.1.</span> <span class="nav-text">keep-alive</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#杂项"><span class="nav-number">7.</span> <span class="nav-text">杂项</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#编写可复用组件"><span class="nav-number">7.1.</span> <span class="nav-text">编写可复用组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#子组件索引"><span class="nav-number">7.2.</span> <span class="nav-text">子组件索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#异步组件"><span class="nav-number">7.3.</span> <span class="nav-text">异步组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#高级异步组件（2-3-0新增）"><span class="nav-number">7.4.</span> <span class="nav-text">高级异步组件（2.3.0新增）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#组件命名约定"><span class="nav-number">7.5.</span> <span class="nav-text">组件命名约定</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#递归组件"><span class="nav-number">7.6.</span> <span class="nav-text">递归组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#组件间的循环引用Circular-References-Between-Components"><span class="nav-number">7.7.</span> <span class="nav-text">组件间的循环引用Circular References Between Components</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内联模板"><span class="nav-number">7.8.</span> <span class="nav-text">内联模板</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#X-Templates"><span class="nav-number">7.9.</span> <span class="nav-text">X-Templates</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xue Ling</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  

    
      <script id="dsq-count-scr" src="https://xuelinglong.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://yoursite.com/2017/06/10/Vue-组件/';
          this.page.identifier = '2017/06/10/Vue-组件/';
          this.page.title = 'Vue-组件';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://xuelinglong.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  













  





  

  

  

  

  

</body>
</html>
